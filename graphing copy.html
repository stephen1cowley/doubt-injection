<!DOCTYPE html>
<html>
<head>
    <title>LLM Results Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif;
        }
        .container {
            display: flex;
            max-width: 100%;
            margin: 0 auto;
            height: 100vh;
        }
        .controls {
            width: 200px;
            padding: 20px;
            background: #fafafa;
            border-right: 1px solid #eee;
            overflow-y: auto;
            height: 100vh;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .controls h3 {
            font-weight: 600;
            color: #2f3640;
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 16px;
        }
        .controls button {
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 12px;
            margin: 0 5px 10px 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }
        .controls button:hover {
            background: #f8f9fa;
            border-color: #ccc;
        }
        .graph {
            flex-grow: 1;
            padding: 20px;
            height: 100%;
            overflow: auto;
        }
        .checkbox-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
            background: #fff;
            margin-bottom: 15px;
        }
        .checkbox-list div {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        .checkbox-list input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            cursor: pointer;
        }
        .checkbox-list label {
            font-size: 14px;
            color: #444;
            cursor: pointer;
            user-select: none;
        }
        .file-input {
            margin: 0 auto;
            padding: 10px 0;
            display: block;
            width: 100%;
            font-size: 14px;
        }
        .toggle-container {
            margin: 15px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
            margin-right: 10px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(32px);
        }
        .toggle-label {
            display: inline-block;
            vertical-align: middle;
            font-size: 14px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <input type="file" accept=".json" class="file-input">
            
            <!-- Add data structure toggle -->
            <div class="toggle-container">
                <div style="margin-bottom: 8px; font-weight: 600;">Data Structure:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="dataStructureToggle" onclick="updatePlot()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="toggleLabel">Accuracy Data</span>
            </div>
            
            <!-- Add Beta Distribution Mode toggle -->
            <div class="toggle-container">
                <div style="margin-bottom: 8px; font-weight: 600;">Beta Distribution Mode:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="betaModeToggle" onclick="toggleBetaMode()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="betaModeLabel">Off</span>
            </div>
            
            <!-- Beta Distribution Controls -->
            <div id="betaControls" style="display: none; margin-bottom: 15px;">
                <h3>Beta Distribution Parameters:</h3>
                
                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin: 0 0 10px 0; color: #d32f2f;">Distribution 1 (Red):</h4>
                    <div style="margin-bottom: 10px;">
                        <label for="beta1Alpha" style="display: block; margin-bottom: 5px;">Alpha (α):</label>
                        <input type="number" id="beta1Alpha" min="0.1" step="0.1" value="2" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="beta1Beta" style="display: block; margin-bottom: 5px;">Beta (β):</label>
                        <input type="number" id="beta1Beta" min="0.1" step="0.1" value="5" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                </div>
                
                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin: 0 0 10px 0; color: #1976d2;">Distribution 2 (Blue):</h4>
                    <div style="margin-bottom: 10px;">
                        <label for="beta2Alpha" style="display: block; margin-bottom: 5px;">Alpha (α):</label>
                        <input type="number" id="beta2Alpha" min="0.1" step="0.1" value="5" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="beta2Beta" style="display: block; margin-bottom: 5px;">Beta (β):</label>
                        <input type="number" id="beta2Beta" min="0.1" step="0.1" value="2" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                </div>
            </div>
            
            <div id="questionSection">
                <h3>Select Questions:</h3>
                <button onclick="selectAll('questions')">Select All</button>
                <button onclick="deselectAll('questions')">Deselect All</button>
                <div class="checkbox-list" id="questionList"></div>
            </div>

            <!-- Add new section for probability selection -->
            <h3>Select Probabilities:</h3>
            <button onclick="selectAll('probs')">Select All</button>
            <button onclick="deselectAll('probs')">Deselect All</button>
            <div class="checkbox-list" id="probList"></div>

            <!-- Add customization controls for title and y-axis -->
            <h3>Customize Chart:</h3>
            <div style="margin-bottom: 15px;">
                <label for="chartTitle" style="display: block; margin-bottom: 5px;">Chart Title:</label>
                <input type="text" id="chartTitle" placeholder="Accuracy vs Temperature" 
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="xAxisLabel" style="display: block; margin-bottom: 5px;">X-Axis Label:</label>
                <input type="text" id="xAxisLabel" placeholder="Temperature" 
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="yAxisLabel" style="display: block; margin-bottom: 5px;">Y-Axis Label:</label>
                <input type="text" id="yAxisLabel" placeholder="Accuracy" 
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <!-- Add display options -->
            <h3>Display Options:</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showTitle" checked onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Title</span>
                </label>
                
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showLegend" checked onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Legend</span>
                </label>
                
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showErrorBars" checked onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Error Bars</span>
                </label>

                <label style="display: flex; align-items: center;">
                    <input type="checkbox" id="colorSchemeToggle" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Purple-Green Color Scheme</span>
                </label>

                <label style="display: flex; align-items: center;">
                    <input type="checkbox" id="forceWholeTicks" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Force Whole Number X-Axis Ticks</span>
                </label>
            </div>
            
            <!-- Add bar chart specific options -->
            <div id="barChartOptions" style="margin-bottom: 15px; display: none;">
                <h4 style="margin-top: 10px; margin-bottom: 10px; font-size: 14px;">Bar Chart Options:</h4>
                
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="wideBarMode" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Wide Bars</span>
                </label>
                
                <div style="margin-top: 10px;">
                    <label for="barWidth" style="display: block; margin-bottom: 5px;">Bar Width (0.1-1.0):</label>
                    <input type="range" id="barWidth" min="0.1" max="1.0" step="0.05" value="0.5"
                           style="width: 100%;" oninput="updateBarWidthValue(this.value)" onchange="updatePlot()">
                    <div id="barWidthValue" style="text-align: center; margin-top: 5px;">0.5</div>
                </div>
            </div>
            
            <!-- Add plot size controls -->
            <h3>Plot Size:</h3>
            <div style="margin-bottom: 15px;">
                <label for="plotWidth" style="display: block; margin-bottom: 5px;">Plot Width (px):</label>
                <input type="number" id="plotWidth" placeholder="800" min="300" max="2000" step="50" value="800"
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="plotHeight" style="display: block; margin-bottom: 5px;">Plot Height (px):</label>
                <input type="number" id="plotHeight" placeholder="600" min="300" max="1500" step="50" value="600"
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <button id="resetDimensions" style="width: 100%; padding: 8px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    Reset Plot Size to Default
                </button>
            </div>

            <!-- Add horizontal line controls -->
            <h3>Horizontal Line:</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showHorizontalLine" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Horizontal Line</span>
                </label>
                
                <div style="margin-top: 10px;">
                    <label for="horizontalLineValue" style="display: block; margin-bottom: 5px;">Line Value:</label>
                    <input type="number" id="horizontalLineValue" step="0.01" value="0.5" 
                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                           onchange="updatePlot()">
                </div>
            </div>
        </div>
        <div class="graph" id="plot"></div>
    </div>

    <script>
        // Global variables to store all data structures
        let accuracyData = null;
        let tokenData = null;
        let injectionData = null;
        
        // Toggle event handler
        document.getElementById('dataStructureToggle').addEventListener('change', function() {
            const toggleLabel = document.getElementById('toggleLabel');
            const questionSection = document.getElementById('questionSection');
            const barChartToggle = document.getElementById('barChartToggle');
            
            if (this.checked) {
                toggleLabel.textContent = "Token Count Data";
                questionSection.style.display = 'none';
                if (barChartToggle) barChartToggle.parentElement.style.display = 'none';
            } else {
                toggleLabel.textContent = "Accuracy Data";
                questionSection.style.display = 'block';
                if (barChartToggle) barChartToggle.parentElement.style.display = 'block';
            }
            
            updatePlot();
        });
        
        // Beta mode toggle function
        function toggleBetaMode() {
            const betaModeToggle = document.getElementById('betaModeToggle');
            const betaModeLabel = document.getElementById('betaModeLabel');
            const betaControls = document.getElementById('betaControls');
            
            if (betaModeToggle.checked) {
                betaModeLabel.textContent = "On";
                betaControls.style.display = 'block';
            } else {
                betaModeLabel.textContent = "Off";
                betaControls.style.display = 'none';
            }
            
            updatePlot();
        }
        
        // Modify file input handling to use the HTML element
        const fileInput = document.querySelector('.file-input');
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            console.log("File selected:", file.name);
            const reader = new FileReader();
            
            reader.onload = function(e) {
                console.log("File loaded, parsing JSON...");
                try {
                    const jsonData = JSON.parse(e.target.result);
                    console.log("JSON parsed, detecting data structure...");
                    
                    // Determine data structure type based on content
                    const isToken = isTokenData(jsonData);
                    const isInjection = isInjectionData(jsonData);
                    console.log("Data structure detection result:", 
                        isToken ? "Token Data" : (isInjection ? "Injection Data" : "Accuracy Data"));
                    
                    if (isToken) {
                        console.log("Setting token data...");
                        tokenData = jsonData;
                        accuracyData = null;
                        injectionData = null;
                        document.getElementById('dataStructureToggle').checked = true;
                        document.getElementById('toggleLabel').textContent = "Token Count Data";
                        document.getElementById('questionSection').style.display = 'none';
                        if (document.getElementById('barChartToggle')) 
                            document.getElementById('barChartToggle').parentElement.style.display = 'none';
                        console.log("Token data set:", Object.keys(tokenData).length, "probabilities");
                    } else if (isInjection) {
                        console.log("Setting injection data...");
                        injectionData = jsonData;
                        accuracyData = null;
                        tokenData = null;
                        document.getElementById('dataStructureToggle').checked = false;
                        document.getElementById('toggleLabel').textContent = "Accuracy Data";
                        document.getElementById('questionSection').style.display = 'block';
                        if (document.getElementById('barChartToggle')) {
                            document.getElementById('barChartToggle').checked = true;
                            document.getElementById('barChartToggle').parentElement.style.display = 'block';
                        }
                        console.log("Injection data set:", Object.keys(injectionData).length, "questions");
                    } else {
                        console.log("Setting accuracy data...");
                        accuracyData = jsonData;
                        tokenData = null;
                        injectionData = null;
                        document.getElementById('dataStructureToggle').checked = false;
                        document.getElementById('toggleLabel').textContent = "Accuracy Data";
                        document.getElementById('questionSection').style.display = 'block';
                        if (document.getElementById('barChartToggle')) {
                            document.getElementById('barChartToggle').checked = false;
                            document.getElementById('barChartToggle').parentElement.style.display = 'block';
                        }
                        console.log("Accuracy data set:", Object.keys(accuracyData).length, "questions");
                    }
                    
                    // Create question checkboxes if accuracy data or injection data
                    const questionList = document.getElementById('questionList');
                    questionList.innerHTML = '';
                    
                    if (accuracyData || injectionData) {
                        const data = accuracyData || injectionData;
                        for (let question in data) {
                            const div = document.createElement('div');
                            div.innerHTML = `
                                <label>
                                    <input type="checkbox" value="${question}" onclick="updatePlot()" checked>
                                    <span>${question}</span>
                                </label>
                            `;
                            questionList.appendChild(div);
                        }
                    }

                    // Create probability checkboxes or injection string checkboxes
                    const probList = document.getElementById('probList');
                    probList.innerHTML = '';
                    
                    let uniqueProbs = [];
                    if (accuracyData) {
                        uniqueProbs = [...new Set(
                            Object.values(accuracyData).flatMap(q => Object.keys(q))
                        )].sort((a, b) => parseFloat(a) - parseFloat(b));
                        console.log("Unique probabilities from accuracy data:", uniqueProbs);
                    } else if (tokenData) {
                        uniqueProbs = Object.keys(tokenData).sort((a, b) => parseFloat(a) - parseFloat(b));
                        console.log("Unique probabilities from token data:", uniqueProbs);
                    } else if (injectionData) {
                        // For injection data, get unique injection strings
                        uniqueProbs = [...new Set(
                            Object.values(injectionData).flatMap(q => Object.keys(q))
                        )];
                        console.log("Unique injection strings:", uniqueProbs);
                    }
                    
                    for (let prob of uniqueProbs) {
                        const div = document.createElement('div');
                        div.innerHTML = `
                            <label>
                                <input type="checkbox" value="${prob}" onclick="updatePlot()" checked>
                                <span>${injectionData ? prob : parseFloat(prob).toFixed(2)}</span>
                            </label>
                        `;
                        probList.appendChild(div);
                    }
                    
                    console.log("Checkboxes created, updating plot...");
                    updatePlot();
                } catch (error) {
                    console.error("Error processing file:", error);
                    alert("Error processing file: " + error.message);
                }
            };
            
            reader.readAsText(file);
        });
        
        // Function to determine if data is token data
        function isTokenData(data) {
            // Check if the data structure matches the token data format
            // Token data has doubt_injection_prob -> temperature -> [mean, 97.5%, 2.5%]
            if (!data) return false;
            
            try {
                console.log("Checking if data is token data format...");
                
                // Check if the structure is an object with at least one key
                const keys = Object.keys(data);
                if (keys.length === 0) return false;
                console.log("Top-level keys:", keys);
                
                // Check the first key's value
                const firstKey = keys[0];
                const firstValue = data[firstKey];
                
                if (typeof firstValue !== 'object' || firstValue === null) return false;
                console.log("First value is an object:", typeof firstValue === 'object');
                
                // Check if the inner structure has temperature keys
                const tempKeys = Object.keys(firstValue);
                if (tempKeys.length === 0) return false;
                console.log("Temperature keys:", tempKeys);
                
                // Check the first temperature value
                const firstTempKey = tempKeys[0];
                const tempValue = firstValue[firstTempKey];
                
                // Check if the value is an array with 3 elements
                if (!Array.isArray(tempValue) || tempValue.length !== 3) {
                    console.log("Value is not an array with 3 elements:", tempValue);
                    return false;
                }
                
                console.log("Value is an array with 3 elements:", tempValue);
                
                // Verify all elements are numbers
                const allNumbers = tempValue.every(val => typeof val === 'number');
                console.log("All elements are numbers:", allNumbers);
                
                return allNumbers;
            } catch (error) {
                console.error("Error detecting data structure:", error);
                return false;
            }
        }

        // Function to determine if data is injection data
        function isInjectionData(data) {
            // Check if the data structure matches the injection data format
            // Injection data has question -> (injection_string -> (correct, total))
            if (!data) return false;
            
            try {
                console.log("Checking if data is injection data format...");
                
                // Check if the structure is an object with at least one key
                const keys = Object.keys(data);
                if (keys.length === 0) return false;
                console.log("Top-level keys:", keys);
                
                // Check the first key's value
                const firstKey = keys[0];
                const firstValue = data[firstKey];
                
                if (typeof firstValue !== 'object' || firstValue === null) return false;
                console.log("First value is an object:", typeof firstValue === 'object');
                
                // Check if the inner structure has injection string keys
                const injectionKeys = Object.keys(firstValue);
                if (injectionKeys.length === 0) return false;
                console.log("Injection string keys:", injectionKeys);
                
                // Check the first injection string value
                const firstInjectionKey = injectionKeys[0];
                const injectionValue = firstValue[firstInjectionKey];
                
                // Check if the value is an array with 2 elements
                if (!Array.isArray(injectionValue) || injectionValue.length !== 2) {
                    console.log("Value is not an array with 2 elements:", injectionValue);
                    return false;
                }
                
                console.log("Value is an array with 2 elements:", injectionValue);
                
                // Verify all elements are numbers
                const allNumbers = injectionValue.every(val => typeof val === 'number');
                console.log("All elements are numbers:", allNumbers);
                
                // Check if at least one injection string is not a number (to distinguish from accuracy data)
                const hasNonNumericKey = injectionKeys.some(key => isNaN(parseFloat(key)));
                console.log("Has non-numeric injection string:", hasNonNumericKey);
                
                return allNumbers && hasNonNumericKey;
            } catch (error) {
                console.error("Error detecting injection data structure:", error);
                return false;
            }
        }

        function updatePlot() {
            try {
                const isBetaMode = document.getElementById('betaModeToggle').checked;
                const isTokenMode = document.getElementById('dataStructureToggle').checked;
                const isBarChartMode = document.getElementById('barChartToggle') && 
                                      document.getElementById('barChartToggle').checked;
                const showErrorBars = document.getElementById('showErrorBars').checked;
                
                console.log("updatePlot called:", {
                    isBetaMode,
                    isTokenMode,
                    isBarChartMode,
                    showErrorBars,
                    hasAccuracyData: !!accuracyData,
                    hasTokenData: !!tokenData,
                    hasInjectionData: !!injectionData
                });
                
                // Get custom title and y-axis label values
                let customTitle = document.getElementById('chartTitle').value;
                let customXAxisLabel = document.getElementById('xAxisLabel').value;
                let customYAxisLabel = document.getElementById('yAxisLabel').value;
                
                let traces = [];
                
                // Check which mode to use
                if (isBetaMode) {
                    console.log("Using beta distribution mode");
                    plotBetaDistributions(traces);
                } else if (isTokenMode && tokenData) {
                    console.log("Using token data mode");
                    // Token data plotting
                    let selectedProbs = Array.from(document.querySelectorAll('#probList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotTokenData(traces, selectedProbs, showErrorBars);
                } else if (!isTokenMode && isBarChartMode && injectionData) {
                    console.log("Using injection bar chart mode");
                    // Injection data bar chart plotting
                    let selectedQuestions = Array.from(document.querySelectorAll('#questionList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    let selectedProbs = Array.from(document.querySelectorAll('#probList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotInjectionBarChart(traces, selectedQuestions, selectedProbs, showErrorBars);
                } else if (!isTokenMode && accuracyData) {
                    console.log("Using accuracy data mode");
                    // Accuracy data plotting
                    let selectedQuestions = Array.from(document.querySelectorAll('#questionList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    let selectedProbs = Array.from(document.querySelectorAll('#probList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotAccuracyData(traces, selectedQuestions, selectedProbs, showErrorBars);
                } else {
                    console.log("No appropriate data for selected mode");
                    // No appropriate data loaded for the selected mode
                    Plotly.newPlot('plot', [], {title: `No ${isBetaMode ? 'beta distribution' : (isTokenMode ? 'token' : (isBarChartMode ? 'injection' : 'accuracy'))} data loaded`});
                    return;
                }
                
                console.log("Traces generated:", traces.length);
                
                // Only proceed if we have traces to plot
                if (traces.length === 0) {
                    console.log("No traces to plot");
                    Plotly.newPlot('plot', [], {title: 'No data to display'});
                    return;
                }
                
                // Find the maximum y value including upper confidence bounds
                let maxY = 0;
                try {
                    // Extract all y values from all traces
                    const allYValues = traces.flatMap(trace => 
                        Array.isArray(trace.y) ? trace.y.filter(y => typeof y === 'number' && !isNaN(y)) : []
                    );
                    
                    console.log("Y values for max calculation:", allYValues.length);
                    
                    // Only calculate max if we have values
                    if (allYValues.length > 0) {
                        maxY = Math.max(...allYValues);
                        console.log("Max Y value:", maxY);
                    } else {
                        // Default max value if no valid y values found
                        maxY = isTokenMode ? 10000 : 1;
                        console.log("Using default max Y value:", maxY);
                    }
                } catch (error) {
                    console.error("Error calculating max Y value:", error);
                    // Default max value if error occurs
                    maxY = isTokenMode ? 10000 : 1;
                }
                
                // Add 10% padding above the maximum value
                const yAxisMax = isTokenMode ? maxY * 1.1 : Math.min(1, maxY * 1.1);
                
                // Get display options
                const showTitle = document.getElementById('showTitle').checked;
                const showLegend = document.getElementById('showLegend').checked;
                
                let layout = {
                    title: showTitle ? {
                        text: customTitle || (isBetaMode
                            ? 'Beta Distribution Comparison<br><span style="font-size:12px">Probability Density Function (PDF)</span>'
                            : (isTokenMode 
                                ? (showErrorBars 
                                    ? 'Token Count vs Temperature<br><span style="font-size:12px">Shaded areas represent interquartile range</span>'
                                    : 'Token Count vs Temperature')
                                : (isBarChartMode
                                    ? 'Accuracy by Injection String<br><span style="font-size:12px">Comparing different injection strings</span>'
                                    : (showErrorBars 
                                        ? 'Accuracy vs Temperature<br><span style="font-size:12px">Shaded areas represent 95% confidence intervals from Beta distribution</span>'
                                        : 'Accuracy vs Temperature')))),
                        font: { size: 18 }
                    } : null,
                    xaxis: {
                        title: {
                            text: customXAxisLabel || (isBetaMode ? 'x' : (isBarChartMode ? (isTokenMode ? 'Temperature' : 'Accuracy') : 'Temperature')),
                            standoff: 5
                        },
                        tickangle: isBarChartMode ? 0 : undefined, // Horizontal text for bar chart
                        tickfont: isBarChartMode ? { size: 12 } : undefined, // Smaller font for bar chart
                        tickmode: isBarChartMode && !isTokenMode ? undefined : undefined, // Use array tickmode for bar chart
                        tickvals: isBarChartMode && !isTokenMode && traces.length > 0 && traces[0].x ? 
                                 undefined : undefined, // Position ticks at bar positions
                        ticktext: isBarChartMode && !isTokenMode && traces.length > 0 && traces[0].x ? 
                                 undefined : undefined,
                        // Add forced whole number ticks if enabled (not for beta mode)
                        dtick: !isBetaMode && document.getElementById('forceWholeTicks').checked ? 1 : undefined,
                        // For horizontal bar charts with accuracy data, set the range from 0 to max value with padding
                        range: isBarChartMode && !isTokenMode ? [0, isTokenMode ? null : Math.min(1, maxY * 1.1)] : 
                               (isBetaMode ? [0, 1] : undefined)
                    },
                    yaxis: {
                        title: {
                            text: customYAxisLabel || (isBetaMode ? 'Probability Density' : (isTokenMode ? 'Token Count' : (isBarChartMode ? 'Injection String' : 'Accuracy'))),
                            standoff: 5
                        },
                        // Only set range for vertical (non-bar) accuracy charts
                        range: (!isBarChartMode && !isTokenMode && !isBetaMode) ? [0, yAxisMax] : undefined,
                        // For horizontal bar charts, display in the order provided (already sorted)
                        categoryorder: isBarChartMode && !isTokenMode ? 'trace' : undefined,
                        // Reverse the order for horizontal bar charts to have highest at top
                        autorange: isBarChartMode && !isTokenMode ? 'reversed' : undefined,
                        // For horizontal bar charts, adjust the text formatting
                        tickfont: isBarChartMode && !isTokenMode ? { size: 12 } : undefined
                    },
                    hovermode: 'closest',
                    height: parseInt(document.getElementById('plotHeight').value) || 600,
                    width: parseInt(document.getElementById('plotWidth').value) || 800,
                    showlegend: showLegend,
                    font: {
                        color: '#000000'  // Black color for all text
                    },
                    legend: showLegend ? {
                        title: {
                            text: isBetaMode ? 'Beta<br>Distributions' :
                                  (isTokenMode ? 'Doubt<br>Injection<br>Probability' : 
                                   (document.getElementById('barChartToggle') && document.getElementById('barChartToggle').checked ? 
                                    'Injection String' : 'Doubt<br>Injection<br>Probability')),
                            font: { size: 13 }
                        }
                    } : {},
                    margin: isBarChartMode && !isTokenMode ? { l: 250 } : undefined // Add extra left margin for horizontal bar labels
                };
                
                console.log("Plotting with layout:", layout);
                
                // Add horizontal line if enabled
                if (document.getElementById('showHorizontalLine').checked) {
                    const lineValue = parseFloat(document.getElementById('horizontalLineValue').value);
                    traces.push({
                        x: [-1, 4],
                        y: [lineValue, lineValue],
                        type: 'scatter',
                        mode: 'lines',
                        line: {
                            color: 'black',
                            dash: 'dot',
                            width: 1
                        },
                        name: 'Reference Line',
                        showlegend: false,
                        hoverinfo: 'skip'
                    });

                    // Add annotation for the line
                    layout.annotations = [{
                        x: -1,  // Position at the left edge
                        y: lineValue,
                        text: 'previous<br>best',
                        showarrow: false,
                        font: {
                            size: 14,
                            color: 'black'
                        },
                        xanchor: 'left',  // Anchor to left side
                        yanchor: 'bottom',
                        yshift: 2  // Move the label slightly above the line
                    }];
                }
                
                Plotly.newPlot('plot', traces, layout);
                console.log("Plot complete");
            } catch (error) {
                console.error("Error in updatePlot:", error);
                Plotly.newPlot('plot', [], {title: 'Error plotting data: ' + error.message});
            }
        }
        
        // Function to get color stops based on current color scheme
        function getColorStops() {
            const isPurpleGreen = document.getElementById('colorSchemeToggle').checked;
            if (isPurpleGreen) {
                return [
                    { pos: 0, color: [147, 42, 170] },     // Medium-dark Purple
                    { pos: 0.5, color: [50, 100, 167] },   // Medium Teal
                    { pos: 1, color: [0, 180, 0] }        // More Vivid Green
                ];
            } else {
                return [
                    { pos: 0, color: [255, 0, 0] },     // Red
                    { pos: 0.5, color: [255, 0, 255] },  // Magenta
                    { pos: 1, color: [0, 0, 255] }      // Blue
                ];
            }
        }
        
        function plotTokenData(traces, selectedProbs, showErrorBars) {
            console.log("plotTokenData called with:", {
                selectedProbs,
                tokenData: JSON.stringify(tokenData).substring(0, 100) + "...",
                showErrorBars
            });
            
            // Filter uniqueProbs to only include selected probabilities
            let uniqueProbs = selectedProbs.sort((a, b) => parseFloat(a) - parseFloat(b));
            console.log("Unique probs:", uniqueProbs);

            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            for (let i = 0; i < uniqueProbs.length; i++) {
                let prob = uniqueProbs[i];
                console.log(`Processing prob: ${prob}`);
                
                if (!tokenData[prob] || typeof tokenData[prob] !== 'object') {
                    console.log(`Skipping prob ${prob}: invalid data structure`);
                    continue;
                }
                
                let temperatures = [];
                let meanTokens = [];
                let upperBounds = [];
                let lowerBounds = [];
                
                // Normalize position for color interpolation - reversed order
                const normalizedPos = 1 - (i / (uniqueProbs.length - 1 || 1));
                const lineColor = interpolateColor(normalizedPos);
                
                // Extract data for this probability
                console.log(`Extracting data for prob ${prob}:`, tokenData[prob]);
                for (let temp in tokenData[prob]) {
                    const values = tokenData[prob][temp];
                    console.log(`  Temp ${temp}, values:`, values);
                    
                    // Verify the data structure
                    if (!Array.isArray(values) || values.length !== 3) {
                        console.log(`  Skipping temp ${temp}: not an array with 3 elements`);
                        continue;
                    }
                    
                    // Ensure all values are numbers
                    if (!values.every(val => typeof val === 'number')) {
                        console.log(`  Skipping temp ${temp}: not all values are numbers`);
                        continue;
                    }
                    
                    temperatures.push(parseFloat(temp));
                    meanTokens.push(values[0]);  // Mean token count
                    upperBounds.push(values[1]); // 97.5% value
                    lowerBounds.push(values[2]); // 2.5% value
                }
                
                // Skip if no valid data points
                if (temperatures.length === 0) {
                    console.log(`Skipping prob ${prob}: no valid data points`);
                    continue;
                }
                
                console.log(`Data for prob ${prob}:`, {
                    temperatures,
                    meanTokens,
                    upperBounds,
                    lowerBounds
                });
                
                // Sort by temperature
                let sorted = temperatures.map((t, i) => ({
                    temp: t,
                    mean: meanTokens[i],
                    upper: upperBounds[i],
                    lower: lowerBounds[i]
                })).sort((a, b) => a.temp - b.temp);
                
                traces.push({
                    x: sorted.map(p => p.temp),
                    y: sorted.map(p => p.mean),
                    mode: 'lines+markers',
                    name: parseFloat(prob).toFixed(2),
                    line: { color: lineColor },
                    text: sorted.map(p => {
                        return `Mean: ${p.mean.toFixed(2)}<br>97.5%: ${p.upper}<br>2.5%: ${p.lower}`;
                    }),
                    hovertemplate: 'Temperature: %{x}<br>Token Count: %{y:.0f}<br>%{text}<extra></extra>'
                });
                
                console.log(`Added trace for prob ${prob}`);

                if (showErrorBars) {
                    // Add filled confidence intervals
                    traces.push({
                        x: [...sorted.map(p => p.temp), ...sorted.map(p => p.temp).reverse()],
                        y: [...sorted.map(p => p.upper), ...sorted.map(p => p.lower).reverse()],
                        fill: 'toself',
                        fillcolor: lineColor.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                        line: { width: 0 },
                        mode: 'none',
                        showlegend: false,
                        hoverinfo: 'skip',
                        name: parseFloat(prob).toFixed(2) + ' CI'
                    });
                    console.log(`Added error bars for prob ${prob}`);
                }
            }
            
            console.log(`Final traces:`, traces.length);
        }
        
        function plotAccuracyData(traces, selectedQuestions, selectedProbs, showErrorBars) {
            // Filter uniqueProbs to only include selected probabilities
            let uniqueProbs = selectedProbs.sort((a, b) => parseFloat(a) - parseFloat(b));

            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            for (let i = 0; i < uniqueProbs.length; i++) {
                let prob = uniqueProbs[i];
                let temperatures = [];
                let accuracies = [];
                let correctCounts = [];
                let totalCounts = [];
                
                // Normalize position for color interpolation - reversed order
                const normalizedPos = 1 - (i / (uniqueProbs.length - 1 || 1));
                const lineColor = interpolateColor(normalizedPos);
                
                // Aggregate results for selected questions
                let temperatureResults = {};
                
                for (let question of selectedQuestions) {
                    if (!accuracyData[question] || !accuracyData[question][prob]) continue;
                    
                    // Verify the data structure before processing
                    const probData = accuracyData[question][prob];
                    
                    for (let temp in probData) {
                        const value = probData[temp];
                        
                        // Check if the value is an array with at least 2 elements
                        if (!Array.isArray(value) || value.length < 2) continue;
                        
                        const [correct, total] = value;
                        
                        // Ensure correct and total are numbers
                        if (typeof correct !== 'number' || typeof total !== 'number') continue;
                        
                        if (!temperatureResults[temp]) {
                            temperatureResults[temp] = [0, 0];
                        }
                        temperatureResults[temp][0] += correct;
                        temperatureResults[temp][1] += total;
                    }
                }
                
                // Convert to arrays for plotting
                for (let [temp, [correct, total]] of Object.entries(temperatureResults)) {
                    temperatures.push(parseFloat(temp));
                    accuracies.push(correct / total);
                    correctCounts.push(correct);
                    totalCounts.push(total);
                }
                
                // Sort by temperature
                let sorted = temperatures.map((t, i) => ({
                    temp: t,
                    acc: accuracies[i],
                    correct: correctCounts[i],
                    total: totalCounts[i]
                })).sort((a, b) => a.temp - b.temp);
                
                traces.push({
                    x: sorted.map(p => p.temp),
                    y: sorted.map(p => p.acc),
                    mode: 'lines+markers',
                    name: parseFloat(prob).toFixed(2),
                    line: { color: lineColor },
                    text: sorted.map(p => {
                        const alpha = p.correct + 1;
                        const beta = (p.total - p.correct) + 1;
                        return `Correct: ${p.correct}<br>Total: ${p.total}<br>Beta(${alpha}, ${beta})`;
                    }),
                    hovertemplate: 'Temperature: %{x}<br>Accuracy: %{y:.3f}<br>%{text}<extra></extra>'
                });

                if (showErrorBars) {
                    // Calculate Beta distribution confidence intervals
                    // For each point, we have a Beta(α, β) distribution where:
                    // α = number of successes + 1 (adding 1 for Bayesian prior)
                    // β = number of failures + 1 (adding 1 for Bayesian prior)
                    
                    // Calculate 95% confidence intervals using Beta distribution
                    const lowerBounds = sorted.map(p => {
                        const alpha = p.correct + 1; // Add 1 to match the Beta distribution
                        const beta = (p.total - p.correct) + 1; // Add 1 to match the Beta distribution
                        return jStat.beta.inv(0.025, alpha, beta); // 2.5% quantile
                    });
                    
                    const upperBounds = sorted.map(p => {
                        const alpha = p.correct + 1; // Add 1 to match the Beta distribution
                        const beta = (p.total - p.correct) + 1; // Add 1 to match the Beta distribution
                        return jStat.beta.inv(0.975, alpha, beta); // 97.5% quantile
                    });
                    
                    // Add filled confidence intervals
                    traces.push({
                        x: [...sorted.map(p => p.temp), ...sorted.map(p => p.temp).reverse()],
                        y: [...upperBounds, ...lowerBounds.reverse()],
                        fill: 'toself',
                        fillcolor: lineColor.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                        line: { width: 0 },
                        mode: 'none',
                        showlegend: false,
                        hoverinfo: 'skip',
                        name: parseFloat(prob).toFixed(2) + ' CI'
                    });
                }
            }
        }
        
        function plotInjectionBarChart(traces, selectedQuestions, selectedInjections, showErrorBars) {
            console.log("plotInjectionBarChart called with:", {
                selectedQuestions,
                selectedInjections,
                showErrorBars
            });
            
            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            // Aggregate results for all selected questions
            let injectionResults = {};
            let totalQuestions = selectedQuestions.length;
            
            // Initialize with zeros
            for (let injection of selectedInjections) {
                injectionResults[injection] = [0, 0]; // [correct, total]
            }
            
            // Aggregate data
            for (let question of selectedQuestions) {
                if (!injectionData[question]) continue;
                
                for (let injection of selectedInjections) {
                    if (!injectionData[question][injection]) continue;
                    
                    const [correct, total] = injectionData[question][injection];
                    injectionResults[injection][0] += correct;
                    injectionResults[injection][1] += total;
                }
            }
            
            // Convert to arrays for plotting
            let injections = [];
            let accuracies = [];
            let correctCounts = [];
            let totalCounts = [];
            let errorBars = [];
            
            for (let injection of selectedInjections) {
                if (!injectionResults[injection] || injectionResults[injection][1] === 0) continue;
                
                const [correct, total] = injectionResults[injection];
                const accuracy = correct / total;
                
                injections.push(injection);
                accuracies.push(accuracy);
                correctCounts.push(correct);
                totalCounts.push(total);
                
                // Calculate confidence intervals using Beta distribution
                if (showErrorBars) {
                    const alpha = correct + 1; // Add 1 for Bayesian prior
                    const beta = (total - correct) + 1; // Add 1 for Bayesian prior
                    const lowerBound = jStat.beta.inv(0.025, alpha, beta); // 2.5% quantile
                    const upperBound = jStat.beta.inv(0.975, alpha, beta); // 97.5% quantile
                    
                    errorBars.push([lowerBound, upperBound]);
                }
            }
            
            // Sort by accuracy (in descending order for horizontal bars with highest at top)
            let sorted = injections.map((inj, i) => ({
                injection: inj,
                accuracy: accuracies[i],
                correct: correctCounts[i],
                total: totalCounts[i],
                errorBar: showErrorBars ? errorBars[i] : null
            })).sort((a, b) => b.accuracy - a.accuracy); // Sort by descending accuracy so highest appears at top
            
            // Format injection strings for display
            let formattedInjections = sorted.map(p => {
                let text = p.injection;
                if (text !== '(None)') {
                    text = '"' + text + '"';
                }
                
                const max_line_length = 30; // Increased from 25 to allow more characters per line
                if (text && text.length > max_line_length) {
                    // Split text only at spaces instead of arbitrary character positions
                    const words = text.split(' ');
                    let lines = [];
                    let currentLine = '';
                    
                    // Build lines with maximum length of ~35 characters
                    words.forEach(word => {
                        if (currentLine.length + word.length + 1 <= max_line_length) {
                            currentLine += (currentLine ? ' ' : '') + word;
                        } else {
                            lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    
                    // Add the last line if it's not empty
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    
                    return lines.join('<br>');
                }
                return text;
            });
            
            // Get bar width setting
            const useWideBar = document.getElementById('wideBarMode') && document.getElementById('wideBarMode').checked;
            const barWidth = document.getElementById('barWidth') ? 
                             parseFloat(document.getElementById('barWidth').value) : 0.5;
            
            // Create the horizontal bar chart trace
            traces.push({
                y: formattedInjections,
                x: sorted.map(p => p.accuracy),
                type: 'bar',
                orientation: 'h',
                text: sorted.map(p => {
                    return `Injection: "${p.injection}"<br>Correct: ${p.correct}<br>Total: ${p.total}<br>Accuracy: ${(p.accuracy * 100).toFixed(1)}%`;
                }),
                hovertemplate: 'Accuracy: %{x:.3f}<br>%{text}<extra></extra>',
                marker: {
                    color: sorted.map(p => {
                        // Make "None" bars gray, all others red
                        return p.injection === "(None)" ? 'rgba(128, 128, 128, 0.7)' : 'rgba(255, 0, 0, 0.5)';
                    })
                },
                width: useWideBar ? barWidth : undefined
            });
            
            // Add error bars if requested
            if (showErrorBars) {
                console.log("Adding error bars to horizontal bar chart");
                
                traces.push({
                    y: formattedInjections,
                    x: sorted.map(p => p.accuracy),
                    type: 'scatter',
                    mode: 'markers',
                    marker: { color: 'rgba(0,0,0,0)' },
                    error_x: {
                        type: 'data',
                        array: sorted.map(p => p.errorBar ? p.errorBar[1] - p.accuracy : 0),
                        arrayminus: sorted.map(p => p.errorBar ? p.accuracy - p.errorBar[0] : 0),
                        visible: true,
                        color: 'black',
                        thickness: 1.5,
                        width: 6
                    },
                    showlegend: false,
                    hoverinfo: 'skip'
                });
            }
            
            console.log("Bar chart traces created:", traces.length);
        }
        
        function plotBetaDistributions(traces) {
            console.log("plotBetaDistributions called");
            
            // Get parameters from the input fields
            const alpha1 = parseFloat(document.getElementById('beta1Alpha').value) || 2;
            const beta1 = parseFloat(document.getElementById('beta1Beta').value) || 5;
            const alpha2 = parseFloat(document.getElementById('beta2Alpha').value) || 5;
            const beta2 = parseFloat(document.getElementById('beta2Beta').value) || 2;
            
            console.log("Beta parameters:", { alpha1, beta1, alpha2, beta2 });
            
            // Generate x values from 0 to 1 with fine resolution
            const numPoints = 1000;
            const xValues = [];
            for (let i = 0; i <= numPoints; i++) {
                xValues.push(i / numPoints);
            }
            
            // Calculate PDF values for both distributions
            const yValues1 = xValues.map(x => jStat.beta.pdf(x, alpha1, beta1));
            const yValues2 = xValues.map(x => jStat.beta.pdf(x, alpha2, beta2));
            
            console.log("Generated PDF values, max1:", Math.max(...yValues1), "max2:", Math.max(...yValues2));
            
            // Create traces for both distributions
            traces.push({
                x: xValues,
                y: yValues1,
                type: 'scatter',
                mode: 'lines',
                name: `Beta(${alpha1}, ${beta1})`,
                line: {
                    color: 'rgb(255, 0, 0)',  // Red
                    width: 2
                },
                hovertemplate: 'x: %{x:.3f}<br>PDF: %{y:.3f}<br>Beta(α=%{customdata[0]}, β=%{customdata[1]})<extra></extra>',
                customdata: xValues.map(() => [alpha1, beta1])
            });
            
            traces.push({
                x: xValues,
                y: yValues2,
                type: 'scatter',
                mode: 'lines',
                name: `Beta(${alpha2}, ${beta2})`,
                line: {
                    color: 'rgb(0, 0, 255)',  // Blue
                    width: 2
                },
                hovertemplate: 'x: %{x:.3f}<br>PDF: %{y:.3f}<br>Beta(α=%{customdata[0]}, β=%{customdata[1]})<extra></extra>',
                customdata: xValues.map(() => [alpha2, beta2])
            });
            
            // Add fill under curves if error bars are enabled (reuse this setting for fill)
            const showFill = document.getElementById('showErrorBars').checked;
            if (showFill) {
                // Fill under curve 1
                traces.push({
                    x: [...xValues, ...xValues.slice().reverse()],
                    y: [...yValues1, ...new Array(xValues.length).fill(0)],
                    fill: 'toself',
                    fillcolor: 'rgba(255, 0, 0, 0.2)',
                    line: { width: 0 },
                    mode: 'none',
                    showlegend: false,
                    hoverinfo: 'skip'
                });
                
                // Fill under curve 2
                traces.push({
                    x: [...xValues, ...xValues.slice().reverse()],
                    y: [...yValues2, ...new Array(xValues.length).fill(0)],
                    fill: 'toself',
                    fillcolor: 'rgba(0, 0, 255, 0.2)',
                    line: { width: 0 },
                    mode: 'none',
                    showlegend: false,
                    hoverinfo: 'skip'
                });
            }
            
            console.log("Beta distribution traces created:", traces.length);
        }
        
        function selectAll(type) {
            const selector = type === 'questions' ? '#questionList' : '#probList';
            document.querySelectorAll(`${selector} input[type="checkbox"]`).forEach(cb => cb.checked = true);
            updatePlot();
        }
        
        function deselectAll(type) {
            const selector = type === 'questions' ? '#questionList' : '#probList';
            document.querySelectorAll(`${selector} input[type="checkbox"]`).forEach(cb => cb.checked = false);
            updatePlot();
        }
        
        // Function to load sample token data for testing
        function loadSampleTokenData() {
            console.log("Loading sample token data...");
            
            // Sample token data structure based on the actual data
            const sampleData = {
                "0.5": {
                    "0.6": [2624.11, 10000, 631],
                    "0.75": [2478.01, 10000, 542],
                    "0.9": [2553.97, 5626, 430],
                    "1.0": [2790.3, 5545, 572],
                    "1.1": [3202.57, 7398, 480],
                    "0.0": [3936.05, 10000, 778],
                    "0.25": [2994.65, 10000, 843],
                    "0.5": [2326.55, 10000, 466],
                    "1.25": [4494.6, 10000, 420],
                    "1.5": [9182.6, 10000, 306]
                },
                "0.0": {
                    "0.6": [2492.97, 10000, 435],
                    "0.75": [2244.27, 5619, 381],
                    "0.9": [2558.89, 5916, 440],
                    "1.0": [2375.8, 4716, 448],
                    "1.1": [3036.61, 6052, 427],
                    "0.0": [3304.7, 10000, 777],
                    "0.25": [2044.75, 10000, 444],
                    "0.5": [2817.05, 10000, 706],
                    "1.25": [6032.7, 10000, 2143],
                    "1.5": [8330.55, 10000, 524]
                }
            };
            
            // Set the token data
            tokenData = sampleData;
            accuracyData = null;
            
            // Update UI
            document.getElementById('dataStructureToggle').checked = true;
            document.getElementById('toggleLabel').textContent = "Token Count Data";
            document.getElementById('questionSection').style.display = 'none';
            
            // Create probability checkboxes
            const probList = document.getElementById('probList');
            probList.innerHTML = '';
            
            const uniqueProbs = Object.keys(tokenData).sort((a, b) => parseFloat(a) - parseFloat(b));
            console.log("Unique probabilities from sample token data:", uniqueProbs);
            
            for (let prob of uniqueProbs) {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label>
                        <input type="checkbox" value="${prob}" onclick="updatePlot()" checked>
                        <span>${parseFloat(prob).toFixed(2)}</span>
                    </label>
                `;
                probList.appendChild(div);
            }
            
            console.log("Sample token data loaded, updating plot...");
            updatePlot();
        }
        
        // Add a button to load sample data
        document.addEventListener('DOMContentLoaded', function() {
            const controlsDiv = document.querySelector('.controls');
            const loadSampleButton = document.createElement('button');
            loadSampleButton.textContent = "Load Sample Token Data";
            loadSampleButton.style.marginTop = "15px";
            loadSampleButton.style.width = "100%";
            loadSampleButton.style.padding = "8px";
            loadSampleButton.style.backgroundColor = "#4CAF50";
            loadSampleButton.style.color = "white";
            loadSampleButton.style.border = "none";
            loadSampleButton.style.borderRadius = "4px";
            loadSampleButton.style.cursor = "pointer";
            loadSampleButton.onclick = loadSampleTokenData;
            
            // Insert after file input
            const fileInput = document.querySelector('.file-input');
            fileInput.parentNode.insertBefore(loadSampleButton, fileInput.nextSibling);
            
            // Set default values for plot dimensions
            document.getElementById('plotWidth').value = Math.min(500, window.innerWidth - 250);
            document.getElementById('plotHeight').value = Math.min(450, window.innerHeight - 50);
            
            // Add reset dimensions button event listener
            document.getElementById('resetDimensions').addEventListener('click', function() {
                document.getElementById('plotWidth').value = Math.min(500, window.innerWidth - 250);
                document.getElementById('plotHeight').value = Math.min(450, window.innerHeight - 50);
                updatePlot();
            });
        });
        
        // Add window resize handler
        window.addEventListener('resize', function() {
            // Only update if the plot is already displayed
            if (document.getElementById('plot').innerHTML !== '') {
                updatePlot();
            }
        });
        
        // Add bar chart toggle to the controls
        document.addEventListener('DOMContentLoaded', function() {
            // Add bar chart toggle
            const toggleContainer = document.createElement('div');
            toggleContainer.className = 'toggle-container';
            toggleContainer.innerHTML = `
                <div style="margin-bottom: 8px; font-weight: 600;">Chart Type:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="barChartToggle" onclick="toggleBarChartMode()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="barChartToggleLabel">Line Chart</span>
            `;
            
            // Insert after data structure toggle
            const dataStructureToggle = document.querySelector('.toggle-container');
            dataStructureToggle.parentNode.insertBefore(toggleContainer, dataStructureToggle.nextSibling);
            
            // Add event listener for bar chart toggle
            document.getElementById('barChartToggle').addEventListener('change', function() {
                toggleBarChartMode();
            });
            
            // Function to update bar width value display
            window.updateBarWidthValue = function(val) {
                document.getElementById('barWidthValue').textContent = val;
            };
            
            // Function to toggle bar chart mode
            window.toggleBarChartMode = function() {
                const toggleLabel = document.getElementById('barChartToggleLabel');
                const barChartOptions = document.getElementById('barChartOptions');
                
                if (document.getElementById('barChartToggle').checked) {
                    toggleLabel.textContent = "Bar Chart";
                    barChartOptions.style.display = 'block';
                } else {
                    toggleLabel.textContent = "Line Chart";
                    barChartOptions.style.display = 'none';
                }
                updatePlot();
            };
            
            // Load sample injection data function
            window.loadSampleInjectionData = function() {
                console.log("Loading sample injection data...");
                
                // Sample injection data structure
                const sampleData = {
                    "1": {
                        "I'm confused.": [14, 50],
                        "I'm not sure.": [12, 50],
                        "I don't know.": [10, 50],
                        "Let me think...": [18, 50]
                    },
                    "2": {
                        "I'm confused.": [20, 50],
                        "I'm not sure.": [18, 50],
                        "I don't know.": [15, 50],
                        "Let me think...": [22, 50]
                    },
                    "3": {
                        "I'm confused.": [25, 50],
                        "I'm not sure.": [23, 50],
                        "I don't know.": [20, 50],
                        "Let me think...": [28, 50]
                    }
                };
                
                // Set the injection data
                injectionData = sampleData;
                accuracyData = null;
                tokenData = null;
                
                // Update UI
                document.getElementById('dataStructureToggle').checked = false;
                document.getElementById('toggleLabel').textContent = "Accuracy Data";
                document.getElementById('questionSection').style.display = 'block';
                document.getElementById('barChartToggle').checked = true;
                document.getElementById('barChartToggleLabel').textContent = "Bar Chart";
                document.getElementById('barChartToggle').parentElement.style.display = 'block';
                document.getElementById('barChartOptions').style.display = 'block';
                
                // Create question checkboxes
                const questionList = document.getElementById('questionList');
                questionList.innerHTML = '';
                
                for (let question in injectionData) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label>
                            <input type="checkbox" value="${question}" onclick="updatePlot()" checked>
                            <span>${question}</span>
                        </label>
                    `;
                    questionList.appendChild(div);
                }
                
                // Create injection string checkboxes
                const probList = document.getElementById('probList');
                probList.innerHTML = '';
                
                const uniqueInjections = [...new Set(
                    Object.values(injectionData).flatMap(q => Object.keys(q))
                )];
                
                for (let injection of uniqueInjections) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label>
                            <input type="checkbox" value="${injection}" onclick="updatePlot()" checked>
                            <span>${injection}</span>
                        </label>
                    `;
                    probList.appendChild(div);
                }
                
                console.log("Sample injection data loaded, updating plot...");
                updatePlot();
            };
            
            // Add sample injection data button
            const loadSampleInjectionButton = document.createElement('button');
            loadSampleInjectionButton.textContent = "Load Sample Injection Data";
            loadSampleInjectionButton.style.marginTop = "10px";
            loadSampleInjectionButton.style.width = "100%";
            loadSampleInjectionButton.style.padding = "8px";
            loadSampleInjectionButton.style.backgroundColor = "#9C27B0";
            loadSampleInjectionButton.style.color = "white";
            loadSampleInjectionButton.style.border = "none";
            loadSampleInjectionButton.style.borderRadius = "4px";
            loadSampleInjectionButton.style.cursor = "pointer";
            loadSampleInjectionButton.onclick = window.loadSampleInjectionData;
            
            // Insert after sample token data button
            const loadSampleButton = document.querySelector('.controls button');
            loadSampleButton.parentNode.insertBefore(loadSampleInjectionButton, loadSampleButton.nextSibling);
        });
    </script>
</body>
</html> 