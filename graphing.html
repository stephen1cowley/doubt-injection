<!DOCTYPE html>
<html>
<head>
    <title>LLM Results Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Open Sans', 'Helvetica Neue', Arial, sans-serif;
        }
        .container {
            display: flex;
            max-width: 100%;
            margin: 0 auto;
            height: 100vh;
        }
        .controls {
            width: 200px;
            padding: 20px;
            background: #fafafa;
            border-right: 1px solid #eee;
            overflow-y: auto;
            height: 100vh;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .controls h3 {
            font-weight: 600;
            color: #2f3640;
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 16px;
        }
        .controls button {
            background: #fff;
            border: 1px solid #ddd;
            padding: 8px 12px;
            margin: 0 5px 10px 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }
        .controls button:hover {
            background: #f8f9fa;
            border-color: #ccc;
        }
        .graph {
            flex-grow: 1;
            padding: 20px;
            height: 100%;
            overflow: auto;
        }
        .checkbox-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
            background: #fff;
            margin-bottom: 15px;
        }
        .checkbox-list div {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        .checkbox-list input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            cursor: pointer;
        }
        .checkbox-list label {
            font-size: 14px;
            color: #444;
            cursor: pointer;
            user-select: none;
        }
        .file-input {
            margin: 0 auto;
            padding: 10px 0;
            display: block;
            width: 100%;
            font-size: 14px;
        }
        .toggle-container {
            margin: 15px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 28px;
            margin-right: 10px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:checked + .slider:before {
            transform: translateX(32px);
        }
        .toggle-label {
            display: inline-block;
            vertical-align: middle;
            font-size: 14px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <input type="file" accept=".json" class="file-input">
            
            <!-- Add data structure toggle -->
            <div class="toggle-container">
                <div style="margin-bottom: 8px; font-weight: 600;">Data Structure:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="dataStructureToggle" onclick="updatePlot()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="toggleLabel">Accuracy Data</span>
            </div>
            
            <!-- Add Beta Distribution Mode toggle -->
            <div class="toggle-container">
                <div style="margin-bottom: 8px; font-weight: 600;">Beta Distribution Mode:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="betaModeToggle" onclick="toggleBetaMode()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="betaModeLabel">Off</span>
            </div>
            
            <!-- Add Beta Mode 2 toggle -->
            <div class="toggle-container">
                <div style="margin-bottom: 8px; font-weight: 600;">Beta Mode 2 (CI Display):</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="betaMode2Toggle" onclick="toggleBetaMode2()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="betaMode2Label">Off</span>
            </div>
            
            <!-- Add Equal Question Weighting toggle -->
            <div class="toggle-container">
                <div style="margin-bottom: 8px; font-weight: 600;">Equal Question Weighting:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="equalWeightingToggle" onclick="updatePlot()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="equalWeightingLabel">Off</span>
            </div>
            
            <!-- Beta Distribution Controls -->
            <div id="betaControls" style="display: none; margin-bottom: 15px;">
                <h3>Beta Distribution Parameters:</h3>
                
                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin: 0 0 10px 0; color: #d32f2f;">Distribution 1 (Red):</h4>
                    <div style="margin-bottom: 10px;">
                        <label for="beta1Alpha" style="display: block; margin-bottom: 5px;">Alpha (α):</label>
                        <input type="number" id="beta1Alpha" min="0.1" step="0.1" value="2" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="beta1Beta" style="display: block; margin-bottom: 5px;">Beta (β):</label>
                        <input type="number" id="beta1Beta" min="0.1" step="0.1" value="5" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                </div>
                
                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin: 0 0 10px 0; color: #1976d2;">Distribution 2 (Blue):</h4>
                    <div style="margin-bottom: 10px;">
                        <label for="beta2Alpha" style="display: block; margin-bottom: 5px;">Alpha (α):</label>
                        <input type="number" id="beta2Alpha" min="0.1" step="0.1" value="5" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="beta2Beta" style="display: block; margin-bottom: 5px;">Beta (β):</label>
                        <input type="number" id="beta2Beta" min="0.1" step="0.1" value="2" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                </div>
            </div>
            
            <!-- Beta Mode 2 Controls -->
            <div id="betaMode2Controls" style="display: none; margin-bottom: 15px;">
                <h3>Beta Distribution Parameters:</h3>
                
                <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin: 0 0 10px 0; color: #1976d2;">Beta Distribution:</h4>
                    <div style="margin-bottom: 10px;">
                        <label for="betaMode2Alpha" style="display: block; margin-bottom: 5px;">Alpha (α):</label>
                        <input type="number" id="betaMode2Alpha" min="0.1" step="0.1" value="2" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="betaMode2Beta" style="display: block; margin-bottom: 5px;">Beta (β):</label>
                        <input type="number" id="betaMode2Beta" min="0.1" step="0.1" value="5" 
                               style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                               onchange="updatePlot()">
                    </div>
                </div>
            </div>
            
            <!-- Histogram Controls -->
            <div id="histogramControls" style="display: none; margin-bottom: 15px;">
                <h3>Histogram Parameters:</h3>
                
                <div style="margin-bottom: 15px;">
                    <label for="histogramBinSize" style="display: block; margin-bottom: 5px;">Bin Size:</label>
                    <input type="number" id="histogramBinSize" min="1" step="1" value="400" 
                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                           onchange="updatePlot()">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center;">
                        <input type="checkbox" id="histogramNormalize" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                        <span>Normalize to Probability Density</span>
                    </label>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center;">
                        <input type="checkbox" id="histogramOverlay" onclick="updatePlot()" checked style="margin-right: 10px; width: 18px; height: 18px;">
                        <span>Overlay Histograms</span>
                    </label>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label for="histogramOpacity" style="display: block; margin-bottom: 5px;">Opacity (0.1-1.0):</label>
                    <input type="range" id="histogramOpacity" min="0.1" max="1.0" step="0.05" value="0.7"
                           style="width: 100%;" oninput="updateHistogramOpacityValue(this.value)" onchange="updatePlot()">
                    <div id="histogramOpacityValue" style="text-align: center; margin-top: 5px;">0.7</div>
                </div>
            </div>
            
            <div id="questionSection">
                <h3>Select Questions:</h3>
                <button onclick="selectAll('questions')">Select All</button>
                <button onclick="deselectAll('questions')">Deselect All</button>
                <div class="checkbox-list" id="questionList"></div>
            </div>

            <!-- Add new section for probability selection -->
            <h3>Select Probabilities:</h3>
            <button onclick="selectAll('probs')">Select All</button>
            <button onclick="deselectAll('probs')">Deselect All</button>
            <div class="checkbox-list" id="probList"></div>

            <!-- Add customization controls for title and y-axis -->
            <h3>Customize Chart:</h3>
            <div style="margin-bottom: 15px;">
                <label for="chartTitle" style="display: block; margin-bottom: 5px;">Chart Title:</label>
                <input type="text" id="chartTitle" placeholder="Accuracy vs Temperature" 
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="xAxisLabel" style="display: block; margin-bottom: 5px;">X-Axis Label:</label>
                <input type="text" id="xAxisLabel" placeholder="Temperature" 
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="yAxisLabel" style="display: block; margin-bottom: 5px;">Y-Axis Label:</label>
                <input type="text" id="yAxisLabel" placeholder="Accuracy" 
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <!-- Add display options -->
            <h3>Display Options:</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showTitle" checked onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Title</span>
                </label>
                
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showLegend" checked onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Legend</span>
                </label>
                
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showErrorBars" checked onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Error Bars</span>
                </label>

                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <span style="margin-right: 10px;">Color Scheme:</span>
                    <select id="colorSchemeSelect" onchange="updatePlot()" style="flex: 1; padding: 4px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="default">Red-Magenta-Blue</option>
                        <option value="purpleGreen">Purple-Teal-Green</option>
                        <option value="rainbow">Red-Yellow-Cyan-Blue</option>
                    </select>
                </label>

                <label style="display: flex; align-items: center;">
                    <input type="checkbox" id="forceWholeTicks" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Force Whole Number X-Axis Ticks</span>
                </label>
            </div>
            
            <!-- Add bar chart specific options -->
            <div id="barChartOptions" style="margin-bottom: 15px; display: none;">
                <h4 style="margin-top: 10px; margin-bottom: 10px; font-size: 14px;">Bar Chart Options:</h4>
                
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="wideBarMode" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Wide Bars</span>
                </label>
                
                <div style="margin-top: 10px;">
                    <label for="barWidth" style="display: block; margin-bottom: 5px;">Bar Width (0.1-1.0):</label>
                    <input type="range" id="barWidth" min="0.1" max="1.0" step="0.05" value="0.5"
                           style="width: 100%;" oninput="updateBarWidthValue(this.value)" onchange="updatePlot()">
                    <div id="barWidthValue" style="text-align: center; margin-top: 5px;">0.5</div>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="textLineLength" style="display: block; margin-bottom: 5px;">Text Line Length (15-60 chars):</label>
                    <input type="range" id="textLineLength" min="15" max="60" step="1" value="30"
                           style="width: 100%;" oninput="updateTextLineLengthValue(this.value)" onchange="updatePlot()">
                    <div id="textLineLengthValue" style="text-align: center; margin-top: 5px;">30</div>
                </div>
            </div>
            
            <!-- Add plot size controls -->
            <h3>Plot Size:</h3>
            <div style="margin-bottom: 15px;">
                <label for="plotWidth" style="display: block; margin-bottom: 5px;">Plot Width (px):</label>
                <input type="number" id="plotWidth" placeholder="800" min="300" max="2000" step="50" value="800"
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label for="plotHeight" style="display: block; margin-bottom: 5px;">Plot Height (px):</label>
                <input type="number" id="plotHeight" placeholder="600" min="300" max="1500" step="50" value="600"
                       style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                       onchange="updatePlot()">
            </div>
            
            <div style="margin-bottom: 15px;">
                <button id="resetDimensions" style="width: 100%; padding: 8px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    Reset Plot Size to Default
                </button>
            </div>

            <!-- Add horizontal line controls -->
            <h3>Horizontal Line:</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="showHorizontalLine" onclick="updatePlot()" style="margin-right: 10px; width: 18px; height: 18px;">
                    <span>Show Horizontal Line</span>
                </label>
                
                <div style="margin-top: 10px;">
                    <label for="horizontalLineValue" style="display: block; margin-bottom: 5px;">Line Value:</label>
                    <input type="number" id="horizontalLineValue" step="0.01" value="0.5" 
                           style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                           onchange="updatePlot()">
                </div>
            </div>
        </div>
        <div class="graph" id="plot"></div>
    </div>

    <script>
        // Global variables to store all data structures
        let accuracyData = null;
        let tokenData = null;
        let injectionData = null;
        let histogramData = null;
        
        // Toggle event handler
        document.getElementById('dataStructureToggle').addEventListener('change', function() {
            const toggleLabel = document.getElementById('toggleLabel');
            const questionSection = document.getElementById('questionSection');
            const barChartToggle = document.getElementById('barChartToggle');
            
            if (this.checked) {
                toggleLabel.textContent = "Token Count Data";
                questionSection.style.display = 'none';
                if (barChartToggle) barChartToggle.parentElement.style.display = 'none';
            } else {
                toggleLabel.textContent = "Accuracy Data";
                questionSection.style.display = 'block';
                if (barChartToggle) barChartToggle.parentElement.style.display = 'block';
            }
            
            updatePlot();
        });
        
        // Equal weighting toggle event handler
        document.getElementById('equalWeightingToggle').addEventListener('change', function() {
            const equalWeightingLabel = document.getElementById('equalWeightingLabel');
            equalWeightingLabel.textContent = this.checked ? "On" : "Off";
        });
        
        // Beta mode toggle function
        function toggleBetaMode() {
            const betaModeToggle = document.getElementById('betaModeToggle');
            const betaModeLabel = document.getElementById('betaModeLabel');
            const betaControls = document.getElementById('betaControls');
            
            if (betaModeToggle.checked) {
                betaModeLabel.textContent = "On";
                betaControls.style.display = 'block';
                // Turn off Beta Mode 2 if it's on
                const betaMode2Toggle = document.getElementById('betaMode2Toggle');
                const betaMode2Label = document.getElementById('betaMode2Label');
                const betaMode2Controls = document.getElementById('betaMode2Controls');
                if (betaMode2Toggle.checked) {
                    betaMode2Toggle.checked = false;
                    betaMode2Label.textContent = "Off";
                    betaMode2Controls.style.display = 'none';
                }
            } else {
                betaModeLabel.textContent = "Off";
                betaControls.style.display = 'none';
            }
            
            updatePlot();
        }
        
        // Beta mode 2 toggle function
        function toggleBetaMode2() {
            const betaMode2Toggle = document.getElementById('betaMode2Toggle');
            const betaMode2Label = document.getElementById('betaMode2Label');
            const betaMode2Controls = document.getElementById('betaMode2Controls');
            
            if (betaMode2Toggle.checked) {
                betaMode2Label.textContent = "On";
                betaMode2Controls.style.display = 'block';
                // Turn off Beta Mode 1 if it's on
                const betaModeToggle = document.getElementById('betaModeToggle');
                const betaModeLabel = document.getElementById('betaModeLabel');
                const betaControls = document.getElementById('betaControls');
                if (betaModeToggle.checked) {
                    betaModeToggle.checked = false;
                    betaModeLabel.textContent = "Off";
                    betaControls.style.display = 'none';
                }
            } else {
                betaMode2Label.textContent = "Off";
                betaMode2Controls.style.display = 'none';
            }
            
            updatePlot();
        }
        
        // Modify file input handling to use the HTML element
        const fileInput = document.querySelector('.file-input');
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            console.log("File selected:", file.name);
            const reader = new FileReader();
            
            reader.onload = function(e) {
                console.log("File loaded, parsing JSON...");
                try {
                    const jsonData = JSON.parse(e.target.result);
                    console.log("JSON parsed, detecting data structure...");
                    
                    // Determine data structure type based on content
                    const isToken = isTokenData(jsonData);
                    const isInjection = isInjectionData(jsonData);
                    const isHistogram = isHistogramData(jsonData);
                    console.log("Data structure detection result:", 
                        isToken ? "Token Data" : (isInjection ? "Injection Data" : (isHistogram ? "Histogram Data" : "Accuracy Data")));
                    
                    if (isToken) {
                        console.log("Setting token data...");
                        tokenData = jsonData;
                        accuracyData = null;
                        injectionData = null;
                        histogramData = null;
                        document.getElementById('dataStructureToggle').checked = true;
                        document.getElementById('toggleLabel').textContent = "Token Count Data";
                        document.getElementById('questionSection').style.display = 'none';
                        if (document.getElementById('barChartToggle')) 
                            document.getElementById('barChartToggle').parentElement.style.display = 'none';
                        // Hide histogram controls
                        console.log("Token data set:", Object.keys(tokenData).length, "probabilities");
                    } else if (isInjection) {
                        console.log("Setting injection data...");
                        injectionData = jsonData;
                        accuracyData = null;
                        tokenData = null;
                        histogramData = null;
                        document.getElementById('dataStructureToggle').checked = false;
                        document.getElementById('toggleLabel').textContent = "Accuracy Data";
                        document.getElementById('questionSection').style.display = 'block';
                        if (document.getElementById('barChartToggle')) {
                            document.getElementById('barChartToggle').checked = true;
                            document.getElementById('barChartToggle').parentElement.style.display = 'block';
                        }
                        // Hide histogram controls
                        document.getElementById('histogramControls').style.display = 'none';
                        console.log("Injection data set:", Object.keys(injectionData).length, "questions");
                    } else if (isHistogram) {
                        console.log("Setting histogram data...");
                        histogramData = jsonData;
                        accuracyData = null;
                        tokenData = null;
                        injectionData = null;
                        document.getElementById('dataStructureToggle').checked = false;
                        document.getElementById('toggleLabel').textContent = "Histogram Data";
                        document.getElementById('questionSection').style.display = 'block';
                        if (document.getElementById('barChartToggle')) {
                            document.getElementById('barChartToggle').checked = false;
                            document.getElementById('barChartToggle').parentElement.style.display = 'block';
                        }
                        // Show histogram controls
                        document.getElementById('histogramControls').style.display = 'block';
                        console.log("Histogram data set:", Object.keys(histogramData).length, "data points");
                    } else {
                        console.log("Setting accuracy data...");
                        accuracyData = jsonData;
                        tokenData = null;
                        injectionData = null;
                        histogramData = null;
                        document.getElementById('dataStructureToggle').checked = false;
                        document.getElementById('toggleLabel').textContent = "Accuracy Data";
                        document.getElementById('questionSection').style.display = 'block';
                        if (document.getElementById('barChartToggle')) {
                            document.getElementById('barChartToggle').checked = false;
                            document.getElementById('barChartToggle').parentElement.style.display = 'block';
                        }
                        console.log("Accuracy data set:", Object.keys(accuracyData).length, "questions");
                    }
                    
                    // Create question checkboxes if accuracy data or injection data
                    const questionList = document.getElementById('questionList');
                    questionList.innerHTML = '';
                    
                    if (accuracyData || injectionData) {
                        const data = accuracyData || injectionData;
                        for (let question in data) {
                            const div = document.createElement('div');
                            div.innerHTML = `
                                <label>
                                    <input type="checkbox" value="${question}" onclick="updatePlot()" checked>
                                    <span>${question}</span>
                                </label>
                            `;
                            questionList.appendChild(div);
                        }
                    } else if (histogramData) {
                        // For histogram data, create checkboxes for each category
                        for (let category in histogramData) {
                            const div = document.createElement('div');
                            div.innerHTML = `
                                <label>
                                    <input type="checkbox" value="${category}" onclick="updatePlot()" checked>
                                    <span>${category}</span>
                                </label>
                            `;
                            questionList.appendChild(div);
                        }
                    }

                    // Create probability checkboxes or injection string checkboxes
                    const probList = document.getElementById('probList');
                    probList.innerHTML = '';
                    
                    let uniqueProbs = [];
                    if (accuracyData) {
                        uniqueProbs = [...new Set(
                            Object.values(accuracyData).flatMap(q => Object.keys(q))
                        )].sort((a, b) => parseFloat(a) - parseFloat(b));
                        console.log("Unique probabilities from accuracy data:", uniqueProbs);
                    } else if (tokenData) {
                        uniqueProbs = Object.keys(tokenData).sort((a, b) => parseFloat(a) - parseFloat(b));
                        console.log("Unique probabilities from token data:", uniqueProbs);
                    } else if (injectionData) {
                        // For injection data, get unique injection strings
                        uniqueProbs = [...new Set(
                            Object.values(injectionData).flatMap(q => Object.keys(q))
                        )];
                        console.log("Unique injection strings:", uniqueProbs);
                    }
                    
                    for (let prob of uniqueProbs) {
                        const div = document.createElement('div');
                        div.innerHTML = `
                            <label>
                                <input type="checkbox" value="${prob}" onclick="updatePlot()" checked>
                                <span>${injectionData ? prob : parseFloat(prob).toFixed(2)}</span>
                            </label>
                        `;
                        probList.appendChild(div);
                    }
                    
                    console.log("Checkboxes created, updating plot...");
                    updatePlot();
                } catch (error) {
                    console.error("Error processing file:", error);
                    alert("Error processing file: " + error.message);
                }
            };
            
            reader.readAsText(file);
        });
        
        // Function to determine if data is token data
        function isTokenData(data) {
            // Check if the data structure matches the token data format
            // Token data has doubt_injection_prob -> temperature -> [mean, 97.5%, 2.5%]
            if (!data) return false;
            
            try {
                console.log("Checking if data is token data format...");
                
                // Check if the structure is an object with at least one key
                const keys = Object.keys(data);
                if (keys.length === 0) return false;
                console.log("Top-level keys:", keys);
                
                // Check the first key's value
                const firstKey = keys[0];
                const firstValue = data[firstKey];
                
                if (typeof firstValue !== 'object' || firstValue === null) return false;
                console.log("First value is an object:", typeof firstValue === 'object');
                
                // Check if the inner structure has temperature keys
                const tempKeys = Object.keys(firstValue);
                if (tempKeys.length === 0) return false;
                console.log("Temperature keys:", tempKeys);
                
                // Check the first temperature value
                const firstTempKey = tempKeys[0];
                const tempValue = firstValue[firstTempKey];
                
                // Check if the value is an array with 3 elements
                if (!Array.isArray(tempValue) || tempValue.length !== 3) {
                    console.log("Value is not an array with 3 elements:", tempValue);
                    return false;
                }
                
                console.log("Value is an array with 3 elements:", tempValue);
                
                // Verify all elements are numbers
                const allNumbers = tempValue.every(val => typeof val === 'number');
                console.log("All elements are numbers:", allNumbers);
                
                return allNumbers;
            } catch (error) {
                console.error("Error detecting data structure:", error);
                return false;
            }
        }

        // Function to determine if data is injection data
        function isInjectionData(data) {
            // Check if the data structure matches the injection data format
            // Injection data has question -> (injection_string -> (correct, total))
            if (!data) return false;
            
            try {
                console.log("Checking if data is injection data format...");
                
                // Check if the structure is an object with at least one key
                const keys = Object.keys(data);
                if (keys.length === 0) return false;
                console.log("Top-level keys:", keys);
                
                // Check the first key's value
                const firstKey = keys[0];
                const firstValue = data[firstKey];
                
                if (typeof firstValue !== 'object' || firstValue === null) return false;
                console.log("First value is an object:", typeof firstValue === 'object');
                
                // Check if the inner structure has injection string keys
                const injectionKeys = Object.keys(firstValue);
                if (injectionKeys.length === 0) return false;
                console.log("Injection string keys:", injectionKeys);
                
                // Check the first injection string value
                const firstInjectionKey = injectionKeys[0];
                const injectionValue = firstValue[firstInjectionKey];
                
                // Check if the value is an array with 2 elements
                if (!Array.isArray(injectionValue) || injectionValue.length !== 2) {
                    console.log("Value is not an array with 2 elements:", injectionValue);
                    return false;
                }
                
                console.log("Value is an array with 2 elements:", injectionValue);
                
                // Verify all elements are numbers
                const allNumbers = injectionValue.every(val => typeof val === 'number');
                console.log("All elements are numbers:", allNumbers);
                
                // Check if at least one injection string is not a number (to distinguish from accuracy data)
                const hasNonNumericKey = injectionKeys.some(key => isNaN(parseFloat(key)));
                console.log("Has non-numeric injection string:", hasNonNumericKey);
                
                return allNumbers && hasNonNumericKey;
            } catch (error) {
                console.error("Error detecting injection data structure:", error);
                return false;
            }
        }

        // Function to determine if data is histogram data
        function isHistogramData(data) {
            // Check if the data structure matches the histogram data format
            // Histogram data has Dict[str, List[int]]
            if (!data) return false;
            
            try {
                console.log("Checking if data is histogram data format...");
                
                // Check if the structure is an object with at least one key
                const keys = Object.keys(data);
                if (keys.length === 0) return false;
                console.log("Top-level keys:", keys);
                
                // Check the first key's value
                const firstKey = keys[0];
                const firstValue = data[firstKey];
                
                // Check if the value is an array
                if (!Array.isArray(firstValue)) {
                    console.log("Value is not an array:", typeof firstValue);
                    return false;
                }
                
                console.log("Value is an array with length:", firstValue.length);
                
                // Check if all elements in the array are integers
                const allIntegers = firstValue.every(val => Number.isInteger(val));
                console.log("All elements are integers:", allIntegers);
                
                // Additional check: verify that other keys also have arrays of integers
                for (let key of keys.slice(1, 3)) { // Check up to 3 keys for efficiency
                    const value = data[key];
                    if (!Array.isArray(value) || !value.every(val => Number.isInteger(val))) {
                        console.log(`Key ${key} doesn't have array of integers:`, value);
                        return false;
                    }
                }
                
                return allIntegers;
            } catch (error) {
                console.error("Error detecting histogram data structure:", error);
                return false;
            }
        }

        function updatePlot() {
            try {
                const isBetaMode = document.getElementById('betaModeToggle').checked;
                const isBetaMode2 = document.getElementById('betaMode2Toggle').checked;
                const isTokenMode = document.getElementById('dataStructureToggle').checked;
                const isBarChartMode = document.getElementById('barChartToggle') && 
                                      document.getElementById('barChartToggle').checked;
                const showErrorBars = document.getElementById('showErrorBars').checked;
                
                console.log("updatePlot called:", {
                    isBetaMode,
                    isBetaMode2,
                    isTokenMode,
                    isBarChartMode,
                    showErrorBars,
                    hasAccuracyData: !!accuracyData,
                    hasTokenData: !!tokenData,
                    hasInjectionData: !!injectionData,
                    hasHistogramData: !!histogramData
                });
                
                // Get custom title and y-axis label values
                let customTitle = document.getElementById('chartTitle').value;
                let customXAxisLabel = document.getElementById('xAxisLabel').value;
                let customYAxisLabel = document.getElementById('yAxisLabel').value;
                
                let traces = [];
                
                // Check which mode to use
                if (isBetaMode) {
                    console.log("Using beta distribution mode");
                    plotBetaDistributions(traces);
                } else if (isBetaMode2) {
                    console.log("Using beta distribution mode 2");
                    plotBetaDistribution2(traces);
                } else if (isTokenMode && tokenData) {
                    console.log("Using token data mode");
                    // Token data plotting
                    let selectedProbs = Array.from(document.querySelectorAll('#probList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotTokenData(traces, selectedProbs, showErrorBars);
                } else if (!isTokenMode && isBarChartMode && injectionData) {
                    console.log("Using injection bar chart mode");
                    // Injection data bar chart plotting
                    let selectedQuestions = Array.from(document.querySelectorAll('#questionList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    let selectedProbs = Array.from(document.querySelectorAll('#probList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotInjectionBarChart(traces, selectedQuestions, selectedProbs, showErrorBars);
                } else if (!isTokenMode && histogramData) {
                    console.log("Using histogram data mode");
                    // Histogram data plotting
                    let selectedCategories = Array.from(document.querySelectorAll('#questionList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotHistogramData(traces, selectedCategories);
                } else if (!isTokenMode && accuracyData) {
                    console.log("Using accuracy data mode");
                    // Accuracy data plotting
                    let selectedQuestions = Array.from(document.querySelectorAll('#questionList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    let selectedProbs = Array.from(document.querySelectorAll('#probList input[type="checkbox"]:checked'))
                        .map(cb => cb.value);
                    plotAccuracyData(traces, selectedQuestions, selectedProbs, showErrorBars);
                } else {
                    console.log("No appropriate data for selected mode");
                    // No appropriate data loaded for the selected mode
                    Plotly.newPlot('plot', [], {title: `No ${isBetaMode ? 'beta distribution' : (isBetaMode2 ? 'beta distribution' : (isTokenMode ? 'token' : (isBarChartMode ? 'injection' : (histogramData ? 'histogram' : 'accuracy'))))} data loaded`});
                    return;
                }
                
                console.log("Traces generated:", traces.length);
                
                // Only proceed if we have traces to plot
                if (traces.length === 0) {
                    console.log("No traces to plot");
                    Plotly.newPlot('plot', [], {title: 'No data to display'});
                    return;
                }
                
                // Find the maximum y value including upper confidence bounds
                let maxY = 0;
                try {
                    // Extract all y values from all traces
                    const allYValues = traces.flatMap(trace => 
                        Array.isArray(trace.y) ? trace.y.filter(y => typeof y === 'number' && !isNaN(y)) : []
                    );
                    
                    console.log("Y values for max calculation:", allYValues.length);
                    
                    // Only calculate max if we have values
                    if (allYValues.length > 0) {
                        maxY = Math.max(...allYValues);
                        console.log("Max Y value:", maxY);
                    } else {
                        // Default max value if no valid y values found
                        maxY = isTokenMode ? 10000 : 1;
                        console.log("Using default max Y value:", maxY);
                    }
                } catch (error) {
                    console.error("Error calculating max Y value:", error);
                    // Default max value if error occurs
                    maxY = isTokenMode ? 10000 : 1;
                }
                
                // Add 10% padding above the maximum value
                const yAxisMax = isTokenMode ? maxY * 1.1 : Math.min(1, maxY * 1.1);
                
                // Get display options
                const showTitle = document.getElementById('showTitle').checked;
                const showLegend = document.getElementById('showLegend').checked;
                
                let layout = {
                    title: showTitle ? {
                        text: customTitle || (isBetaMode
                            ? 'Beta Distribution Comparison<br><span style="font-size:12px">Probability Density Function (PDF)</span>'
                            : (isBetaMode2
                                ? 'Beta Distribution Comparison<br><span style="font-size:12px">Beta Distribution</span>'
                                : (isTokenMode 
                                    ? (showErrorBars 
                                        ? 'Token Count vs Temperature<br><span style="font-size:12px">Shaded areas represent interquartile range</span>'
                                        : 'Token Count vs Temperature')
                                    : (histogramData
                                        ? 'Response Length Distribution<br><span style="font-size:12px">Frequency distribution over multiple trials</span>'
                                        : (isBarChartMode
                                            ? 'Accuracy by Injection String<br><span style="font-size:12px">Comparing different injection strings</span>'
                                            : (showErrorBars 
                                                ? 'Accuracy vs Temperature<br><span style="font-size:12px">Shaded areas represent 95% confidence intervals from Beta distribution</span>'
                                                : 'Accuracy vs Temperature')))))),
                        font: { size: 18 }
                    } : null,
                    xaxis: {
                        title: {
                            text: customXAxisLabel || (isBetaMode ? 'x' : (isBetaMode2 ? 'x' : (histogramData ? 'Response Length' : (isBarChartMode ? (isTokenMode ? 'Temperature' : 'Accuracy') : 'Temperature')))),
                            standoff: 5
                        },
                        showline: histogramData ? false : undefined, // Hide x-axis line for histogram mode
                        zeroline: histogramData ? false : undefined, // Hide zero line for histogram mode
                        linewidth: histogramData ? 0 : undefined, // Set line width to 0 for histogram mode
                        linecolor: histogramData ? 'rgba(0,0,0,0)' : undefined, // Make line transparent for histogram mode
                        tickangle: isBarChartMode ? 0 : undefined, // Horizontal text for bar chart
                        tickfont: isBarChartMode ? { size: 12 } : undefined, // Smaller font for bar chart
                        tickmode: isBarChartMode && !isTokenMode ? undefined : undefined, // Use array tickmode for bar chart
                        tickvals: isBarChartMode && !isTokenMode && traces.length > 0 && traces[0].x ? 
                                 undefined : undefined, // Position ticks at bar positions
                        ticktext: isBarChartMode && !isTokenMode && traces.length > 0 && traces[0].x ? 
                                 undefined : undefined,
                        // Add forced whole number ticks if enabled (not for beta mode)
                        dtick: !isBetaMode && !isBetaMode2 && document.getElementById('forceWholeTicks').checked ? 1 : undefined,
                        // For horizontal bar charts with accuracy data, set the range from 0 to max value with padding
                        range: isBarChartMode && !isTokenMode ? [0, isTokenMode ? null : Math.min(1, maxY * 1.1)] : 
                               (isBetaMode ? [0, 1] : (isBetaMode2 ? [0, 1] : undefined))
                    },
                    yaxis: {
                        title: {
                            text: customYAxisLabel || (isBetaMode ? 'Probability Density' : (isBetaMode2 ? 'Probability Density' : (histogramData ? 'Frequency' : (isTokenMode ? 'Token Count' : (isBarChartMode ? 'Injection String' : 'Accuracy'))))),
                            standoff: 5
                        },
                        // Only set range for vertical (non-bar) accuracy charts
                        range: (!isBarChartMode && !isTokenMode && !isBetaMode && !isBetaMode2 && !histogramData) ? [0, yAxisMax] : undefined,
                        // For horizontal bar charts, display in the order provided (already sorted)
                        categoryorder: isBarChartMode && !isTokenMode ? 'trace' : undefined,
                        // Reverse the order for horizontal bar charts to have highest at top
                        autorange: isBarChartMode && !isTokenMode ? 'reversed' : undefined,
                        // For horizontal bar charts, adjust the text formatting and add spacing
                        tickfont: isBarChartMode && !isTokenMode ? { size: 12 } : undefined,
                        // Add padding between labels and axis for bar charts
                        standoff: isBarChartMode && !isTokenMode ? 20 : undefined,
                        // Add space between tick labels and axis line for bar charts
                        ticklen: isBarChartMode && !isTokenMode ? 0 : undefined,
                        tickpad: isBarChartMode && !isTokenMode ? 15 : undefined
                    },
                    hovermode: 'closest',
                    height: parseInt(document.getElementById('plotHeight').value) || 600,
                    width: parseInt(document.getElementById('plotWidth').value) || 800,
                    showlegend: showLegend,
                    font: {
                        color: '#000000'  // Black color for all text
                    },
                    legend: showLegend ? {
                        title: {
                            text: isBetaMode ? 'Beta<br>Distributions' :
                                  (isBetaMode2 ? 'Beta<br>Distribution' :
                                   (histogramData ? 'Doubt<br>Injection<br>Probability' :
                                    (isTokenMode ? 'Doubt<br>Injection<br>Probability' : 
                                     (document.getElementById('barChartToggle') && document.getElementById('barChartToggle').checked ? 
                                      'Injection String' : 'Doubt<br>Injection<br>Probability')))),
                            font: { size: 13 }
                        }
                    } : {},
                    margin: isBarChartMode && !isTokenMode ? { l: 350, r: 50 } : undefined, // Increased left margin for horizontal bar labels with right padding
                    barmode: histogramData && document.getElementById('histogramOverlay') && document.getElementById('histogramOverlay').checked ? 'overlay' : undefined
                };
                
                console.log("Plotting with layout:", layout);
                
                // Add horizontal line if enabled
                if (document.getElementById('showHorizontalLine').checked) {
                    const lineValue = parseFloat(document.getElementById('horizontalLineValue').value);
                    traces.push({
                        x: [-1, 4],
                        y: [lineValue, lineValue],
                        type: 'scatter',
                        mode: 'lines',
                        line: {
                            color: 'black',
                            dash: 'dot',
                            width: 1
                        },
                        name: 'Reference Line',
                        showlegend: false,
                        hoverinfo: 'skip'
                    });

                    // Add annotation for the line
                    layout.annotations = [{
                        x: -1,  // Position at the left edge
                        y: lineValue,
                        text: 'previous<br>best',
                        showarrow: false,
                        font: {
                            size: 14,
                            color: 'black'
                        },
                        xanchor: 'left',  // Anchor to left side
                        yanchor: 'bottom',
                        yshift: 2  // Move the label slightly above the line
                    }];
                }
                
                // Add confidence interval annotation for Beta Mode 2
                if (isBetaMode2 && traces.confidenceIntervalAnnotation) {
                    if (!layout.annotations) {
                        layout.annotations = [];
                    }
                    layout.annotations.push(traces.confidenceIntervalAnnotation);
                    
                    // Also add the mode annotation if it exists
                    if (traces.modeAnnotation) {
                        layout.annotations.push(traces.modeAnnotation);
                    }
                }
                
                Plotly.newPlot('plot', traces, layout);
                console.log("Plot complete");
            } catch (error) {
                console.error("Error in updatePlot:", error);
                Plotly.newPlot('plot', [], {title: 'Error plotting data: ' + error.message});
            }
        }
        
        // Function to get color stops based on current color scheme
        function getColorStops() {
            const colorScheme = document.getElementById('colorSchemeSelect').value;
            if (colorScheme === 'purpleGreen') {
                return [
                    { pos: 0, color: [147, 42, 170] },     // Medium-dark Purple
                    { pos: 0.5, color: [50, 100, 167] },   // Medium Teal
                    { pos: 1, color: [0, 180, 0] }        // More Vivid Green
                ];
            } else if (colorScheme === 'rainbow') {
                return [
                    { pos: 0, color: [255, 0, 0] },       // Red
                    { pos: 0.33, color: [255, 255, 0] },  // Yellow
                    { pos: 0.67, color: [0, 255, 255] },  // Cyan
                    { pos: 1, color: [0, 0, 255] }        // Blue
                ];
            } else {
                return [
                    { pos: 0, color: [255, 0, 0] },     // Red
                    { pos: 0.5, color: [150, 150, 150] },  // Magenta
                    { pos: 1, color: [0, 0, 255] }      // Blue
                ];
            }
        }
        
        function plotTokenData(traces, selectedProbs, showErrorBars) {
            console.log("plotTokenData called with:", {
                selectedProbs,
                tokenData: JSON.stringify(tokenData).substring(0, 100) + "...",
                showErrorBars
            });
            
            // Filter uniqueProbs to only include selected probabilities
            let uniqueProbs = selectedProbs.sort((a, b) => parseFloat(a) - parseFloat(b));
            console.log("Unique probs:", uniqueProbs);

            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            for (let i = 0; i < uniqueProbs.length; i++) {
                let prob = uniqueProbs[i];
                console.log(`Processing prob: ${prob}`);
                
                if (!tokenData[prob] || typeof tokenData[prob] !== 'object') {
                    console.log(`Skipping prob ${prob}: invalid data structure`);
                    continue;
                }
                
                let temperatures = [];
                let meanTokens = [];
                let upperBounds = [];
                let lowerBounds = [];
                
                // Normalize position for color interpolation - reversed order
                const normalizedPos = 1 - (i / (uniqueProbs.length - 1 || 1));
                const lineColor = interpolateColor(normalizedPos);
                
                // Extract data for this probability
                console.log(`Extracting data for prob ${prob}:`, tokenData[prob]);
                for (let temp in tokenData[prob]) {
                    const values = tokenData[prob][temp];
                    console.log(`  Temp ${temp}, values:`, values);
                    
                    // Verify the data structure
                    if (!Array.isArray(values) || values.length !== 3) {
                        console.log(`  Skipping temp ${temp}: not an array with 3 elements`);
                        continue;
                    }
                    
                    // Ensure all values are numbers
                    if (!values.every(val => typeof val === 'number')) {
                        console.log(`  Skipping temp ${temp}: not all values are numbers`);
                        continue;
                    }
                    
                    temperatures.push(parseFloat(temp));
                    meanTokens.push(values[0]);  // Mean token count
                    upperBounds.push(values[1]); // 97.5% value
                    lowerBounds.push(values[2]); // 2.5% value
                }
                
                // Skip if no valid data points
                if (temperatures.length === 0) {
                    console.log(`Skipping prob ${prob}: no valid data points`);
                    continue;
                }
                
                console.log(`Data for prob ${prob}:`, {
                    temperatures,
                    meanTokens,
                    upperBounds,
                    lowerBounds
                });
                
                // Sort by temperature
                let sorted = temperatures.map((t, i) => ({
                    temp: t,
                    mean: meanTokens[i],
                    upper: upperBounds[i],
                    lower: lowerBounds[i]
                })).sort((a, b) => a.temp - b.temp);
                
                traces.push({
                    x: sorted.map(p => p.temp),
                    y: sorted.map(p => p.mean),
                    mode: 'lines+markers',
                    name: parseFloat(prob).toFixed(2),
                    line: { color: lineColor },
                    text: sorted.map(p => {
                        return `Mean: ${p.mean.toFixed(2)}<br>97.5%: ${p.upper}<br>2.5%: ${p.lower}`;
                    }),
                    hovertemplate: 'Temperature: %{x}<br>Token Count: %{y:.0f}<br>%{text}<extra></extra>'
                });
                
                console.log(`Added trace for prob ${prob}`);

                if (showErrorBars) {
                    // Add filled confidence intervals
                    traces.push({
                        x: [...sorted.map(p => p.temp), ...sorted.map(p => p.temp).reverse()],
                        y: [...sorted.map(p => p.upper), ...sorted.map(p => p.lower).reverse()],
                        fill: 'toself',
                        fillcolor: lineColor.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                        line: { width: 0 },
                        mode: 'none',
                        showlegend: false,
                        hoverinfo: 'skip',
                        name: parseFloat(prob).toFixed(2) + ' CI'
                    });
                    console.log(`Added error bars for prob ${prob}`);
                }
            }
            
            console.log(`Final traces:`, traces.length);
        }
        
        function plotAccuracyData(traces, selectedQuestions, selectedProbs, showErrorBars) {
            // Filter uniqueProbs to only include selected probabilities
            let uniqueProbs = selectedProbs.sort((a, b) => parseFloat(a) - parseFloat(b));

            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            // Check if equal weighting is enabled
            const equalWeighting = document.getElementById('equalWeightingToggle').checked;
            
            for (let i = 0; i < uniqueProbs.length; i++) {
                let prob = uniqueProbs[i];
                let temperatures = [];
                let accuracies = [];
                let correctCounts = [];
                let totalCounts = [];
                
                // Normalize position for color interpolation - reversed order
                const normalizedPos = 1 - (i / (uniqueProbs.length - 1 || 1));
                const lineColor = interpolateColor(normalizedPos);
                
                // If equal weighting is enabled, first find the minimum total trials per question
                let minTrialsPerQuestion = Infinity;
                if (equalWeighting && selectedQuestions.length > 1) {
                    for (let question of selectedQuestions) {
                        if (!accuracyData[question] || !accuracyData[question][prob]) continue;
                        
                        const probData = accuracyData[question][prob];
                        let questionTotalTrials = 0;
                        
                        for (let temp in probData) {
                            const value = probData[temp];
                            if (!Array.isArray(value) || value.length < 2) continue;
                            
                            const [correct, total] = value;
                            if (typeof correct !== 'number' || typeof total !== 'number') continue;
                            
                            questionTotalTrials += total;
                        }
                        
                        if (questionTotalTrials > 0) {
                            minTrialsPerQuestion = Math.min(minTrialsPerQuestion, questionTotalTrials);
                        }
                    }
                    
                    // If no valid data found, disable equal weighting for this probability
                    if (minTrialsPerQuestion === Infinity) {
                        minTrialsPerQuestion = null;
                    }
                }
                
                // Aggregate results for selected questions
                let temperatureResults = {};
                
                for (let question of selectedQuestions) {
                    if (!accuracyData[question] || !accuracyData[question][prob]) continue;
                    
                    // Verify the data structure before processing
                    const probData = accuracyData[question][prob];
                    
                    // If equal weighting is enabled, calculate the scaling factor for this question
                    let scalingFactor = 1;
                    if (equalWeighting && minTrialsPerQuestion && selectedQuestions.length > 1) {
                        let questionTotalTrials = 0;
                        for (let temp in probData) {
                            const value = probData[temp];
                            if (!Array.isArray(value) || value.length < 2) continue;
                            
                            const [correct, total] = value;
                            if (typeof correct !== 'number' || typeof total !== 'number') continue;
                            
                            questionTotalTrials += total;
                        }
                        
                        if (questionTotalTrials > 0) {
                            scalingFactor = minTrialsPerQuestion / questionTotalTrials;
                        }
                    }
                    
                    for (let temp in probData) {
                        const value = probData[temp];
                        
                        // Check if the value is an array with at least 2 elements
                        if (!Array.isArray(value) || value.length < 2) continue;
                        
                        const [correct, total] = value;
                        
                        // Ensure correct and total are numbers
                        if (typeof correct !== 'number' || typeof total !== 'number') continue;
                        
                        // Apply scaling factor if equal weighting is enabled
                        const scaledCorrect = Math.round(correct * scalingFactor);
                        const scaledTotal = Math.round(total * scalingFactor);
                        
                        if (!temperatureResults[temp]) {
                            temperatureResults[temp] = [0, 0];
                        }
                        temperatureResults[temp][0] += scaledCorrect;
                        temperatureResults[temp][1] += scaledTotal;
                    }
                }
                
                // Convert to arrays for plotting
                for (let [temp, [correct, total]] of Object.entries(temperatureResults)) {
                    temperatures.push(parseFloat(temp));
                    accuracies.push(correct / total);
                    correctCounts.push(correct);
                    totalCounts.push(total);
                }
                
                // Sort by temperature
                let sorted = temperatures.map((t, i) => ({
                    temp: t,
                    acc: accuracies[i],
                    correct: correctCounts[i],
                    total: totalCounts[i]
                })).sort((a, b) => a.temp - b.temp);
                
                traces.push({
                    x: sorted.map(p => p.temp),
                    y: sorted.map(p => p.acc),
                    mode: 'lines+markers',
                    name: parseFloat(prob).toFixed(2),
                    line: { color: lineColor },
                    text: sorted.map(p => {
                        const alpha = p.correct + 1;
                        const beta = (p.total - p.correct) + 1;
                        const weightingInfo = equalWeighting && selectedQuestions.length > 1 ? 
                            `<br>Equal Weighting: ${minTrialsPerQuestion ? 'ON' : 'OFF'}` : '';
                        return `Correct: ${p.correct}<br>Total: ${p.total}<br>Beta(${alpha}, ${beta})${weightingInfo}`;
                    }),
                    hovertemplate: 'Temperature: %{x}<br>Accuracy: %{y:.3f}<br>%{text}<extra></extra>'
                });

                if (showErrorBars) {
                    // Calculate Beta distribution confidence intervals
                    // For each point, we have a Beta(α, β) distribution where:
                    // α = number of successes + 1 (adding 1 for Bayesian prior)
                    // β = number of failures + 1 (adding 1 for Bayesian prior)
                    
                    // Calculate 95% confidence intervals using Beta distribution
                    const lowerBounds = sorted.map(p => {
                        const alpha = p.correct + 1; // Add 1 to match the Beta distribution
                        const beta = (p.total - p.correct) + 1; // Add 1 to match the Beta distribution
                        return jStat.beta.inv(0.025, alpha, beta); // 2.5% quantile
                    });
                    
                    const upperBounds = sorted.map(p => {
                        const alpha = p.correct + 1; // Add 1 to match the Beta distribution
                        const beta = (p.total - p.correct) + 1; // Add 1 to match the Beta distribution
                        return jStat.beta.inv(0.975, alpha, beta); // 97.5% quantile
                    });
                    
                    // Add filled confidence intervals
                    traces.push({
                        x: [...sorted.map(p => p.temp), ...sorted.map(p => p.temp).reverse()],
                        y: [...upperBounds, ...lowerBounds.reverse()],
                        fill: 'toself',
                        fillcolor: lineColor.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                        line: { width: 0 },
                        mode: 'none',
                        showlegend: false,
                        hoverinfo: 'skip',
                        name: parseFloat(prob).toFixed(2) + ' CI'
                    });
                }
            }
        }
        
        function plotInjectionBarChart(traces, selectedQuestions, selectedInjections, showErrorBars) {
            console.log("plotInjectionBarChart called with:", {
                selectedQuestions,
                selectedInjections,
                showErrorBars
            });
            
            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            // Aggregate results for all selected questions
            let injectionResults = {};
            let totalQuestions = selectedQuestions.length;
            
            // Initialize with zeros
            for (let injection of selectedInjections) {
                injectionResults[injection] = [0, 0]; // [correct, total]
            }
            
            // Aggregate data
            for (let question of selectedQuestions) {
                if (!injectionData[question]) continue;
                
                for (let injection of selectedInjections) {
                    if (!injectionData[question][injection]) continue;
                    
                    const [correct, total] = injectionData[question][injection];
                    injectionResults[injection][0] += correct;
                    injectionResults[injection][1] += total;
                }
            }
            
            // Convert to arrays for plotting
            let injections = [];
            let accuracies = [];
            let correctCounts = [];
            let totalCounts = [];
            let errorBars = [];
            
            for (let injection of selectedInjections) {
                if (!injectionResults[injection] || injectionResults[injection][1] === 0) continue;
                
                const [correct, total] = injectionResults[injection];
                const accuracy = correct / total;
                
                injections.push(injection);
                accuracies.push(accuracy);
                correctCounts.push(correct);
                totalCounts.push(total);
                
                // Calculate confidence intervals using Beta distribution
                if (showErrorBars) {
                    const alpha = correct + 1; // Add 1 for Bayesian prior
                    const beta = (total - correct) + 1; // Add 1 for Bayesian prior
                    const lowerBound = jStat.beta.inv(0.025, alpha, beta); // 2.5% quantile
                    const upperBound = jStat.beta.inv(0.975, alpha, beta); // 97.5% quantile
                    
                    errorBars.push([lowerBound, upperBound]);
                }
            }
            
            // Sort by accuracy (in descending order for horizontal bars with highest at top)
            let sorted = injections.map((inj, i) => ({
                injection: inj,
                accuracy: accuracies[i],
                correct: correctCounts[i],
                total: totalCounts[i],
                errorBar: showErrorBars ? errorBars[i] : null
            })).sort((a, b) => b.accuracy - a.accuracy); // Sort by descending accuracy so highest appears at top
            
            // Format injection strings for display
            let formattedInjections = sorted.map(p => {
                let text = p.injection;
                if (text !== '(None)') {
                    text = '"' + text + '"';
                }
                
                // Get text line length from slider control
                const max_line_length = parseInt(document.getElementById('textLineLength').value) || 30;
                if (text && text.length > max_line_length) {
                    // Split text only at spaces instead of arbitrary character positions
                    const words = text.split(' ');
                    let lines = [];
                    let currentLine = '';
                    
                    // Build lines with maximum length from slider setting
                    words.forEach(word => {
                        if (currentLine.length + word.length + 1 <= max_line_length) {
                            currentLine += (currentLine ? ' ' : '') + word;
                        } else {
                            lines.push(currentLine);
                            currentLine = word;
                        }
                    });
                    
                    // Add the last line if it's not empty
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    
                    return lines.join('<br>');
                }
                return text;
            });
            
            // Get bar width setting
            const useWideBar = document.getElementById('wideBarMode') && document.getElementById('wideBarMode').checked;
            const barWidth = document.getElementById('barWidth') ? 
                             parseFloat(document.getElementById('barWidth').value) : 0.5;
            
            // Create the horizontal bar chart trace
            traces.push({
                y: formattedInjections,
                x: sorted.map(p => p.accuracy),
                type: 'bar',
                orientation: 'h',
                text: sorted.map(p => {
                    return `Injection: "${p.injection}"<br>Correct: ${p.correct}<br>Total: ${p.total}<br>Accuracy: ${(p.accuracy * 100).toFixed(1)}%`;
                }),
                hovertemplate: 'Accuracy: %{x:.3f}<br>%{text}<extra></extra>',
                marker: {
                    color: sorted.map(p => {
                        // Make "None" bars gray, all others red
                        return p.injection === "(None)" ? 'rgba(128, 128, 128, 0.7)' : 'rgba(255, 0, 0, 0.5)';
                    })
                },
                width: useWideBar ? barWidth : undefined
            });
            
            // Add error bars if requested
            if (showErrorBars) {
                console.log("Adding error bars to horizontal bar chart");
                
                traces.push({
                    y: formattedInjections,
                    x: sorted.map(p => p.accuracy),
                    type: 'scatter',
                    mode: 'markers',
                    marker: { color: 'rgba(0,0,0,0)' },
                    error_x: {
                        type: 'data',
                        array: sorted.map(p => p.errorBar ? p.errorBar[1] - p.accuracy : 0),
                        arrayminus: sorted.map(p => p.errorBar ? p.accuracy - p.errorBar[0] : 0),
                        visible: true,
                        color: 'black',
                        thickness: 1.5,
                        width: 6
                    },
                    showlegend: false,
                    hoverinfo: 'skip'
                });
            }
            
            console.log("Bar chart traces created:", traces.length);
        }
        
        function plotBetaDistributions(traces) {
            console.log("plotBetaDistributions called");
            
            // Get parameters from the input fields
            const alpha1 = parseFloat(document.getElementById('beta1Alpha').value) || 2;
            const beta1 = parseFloat(document.getElementById('beta1Beta').value) || 5;
            const alpha2 = parseFloat(document.getElementById('beta2Alpha').value) || 5;
            const beta2 = parseFloat(document.getElementById('beta2Beta').value) || 2;
            
            console.log("Beta parameters:", { alpha1, beta1, alpha2, beta2 });
            
            // Generate x values from 0 to 1 with fine resolution
            const numPoints = 1000;
            const xValues = [];
            for (let i = 0; i <= numPoints; i++) {
                xValues.push(i / numPoints);
            }
            
            // Calculate PDF values for both distributions
            const yValues1 = xValues.map(x => jStat.beta.pdf(x, alpha1, beta1));
            const yValues2 = xValues.map(x => jStat.beta.pdf(x, alpha2, beta2));
            
            console.log("Generated PDF values, max1:", Math.max(...yValues1), "max2:", Math.max(...yValues2));
            
            // Create traces for both distributions
            traces.push({
                x: xValues,
                y: yValues1,
                type: 'scatter',
                mode: 'lines',
                name: `Beta(${alpha1}, ${beta1})`,
                line: {
                    color: 'rgb(255, 0, 0)',  // Red
                    width: 2
                },
                hovertemplate: 'x: %{x:.3f}<br>PDF: %{y:.3f}<br>Beta(α=%{customdata[0]}, β=%{customdata[1]})<extra></extra>',
                customdata: xValues.map(() => [alpha1, beta1])
            });
            
            traces.push({
                x: xValues,
                y: yValues2,
                type: 'scatter',
                mode: 'lines',
                name: `Beta(${alpha2}, ${beta2})`,
                line: {
                    color: 'rgb(0, 0, 255)',  // Blue
                    width: 2
                },
                hovertemplate: 'x: %{x:.3f}<br>PDF: %{y:.3f}<br>Beta(α=%{customdata[0]}, β=%{customdata[1]})<extra></extra>',
                customdata: xValues.map(() => [alpha2, beta2])
            });
            
            // Add fill under curves if error bars are enabled (reuse this setting for fill)
            const showFill = document.getElementById('showErrorBars').checked;
            if (showFill) {
                // Fill under curve 1
                traces.push({
                    x: [...xValues, ...xValues.slice().reverse()],
                    y: [...yValues1, ...new Array(xValues.length).fill(0)],
                    fill: 'toself',
                    fillcolor: 'rgba(255, 0, 0, 0.2)',
                    line: { width: 0 },
                    mode: 'none',
                    showlegend: false,
                    hoverinfo: 'skip'
                });
                
                // Fill under curve 2
                traces.push({
                    x: [...xValues, ...xValues.slice().reverse()],
                    y: [...yValues2, ...new Array(xValues.length).fill(0)],
                    fill: 'toself',
                    fillcolor: 'rgba(0, 0, 255, 0.2)',
                    line: { width: 0 },
                    mode: 'none',
                    showlegend: false,
                    hoverinfo: 'skip'
                });
            }
            
            console.log("Beta distribution traces created:", traces.length);
        }
        
        function plotBetaDistribution2(traces) {
            console.log("plotBetaDistribution2 called");
            
            // Get parameters from the input fields
            const alpha = parseFloat(document.getElementById('betaMode2Alpha').value) || 2;
            const beta = parseFloat(document.getElementById('betaMode2Beta').value) || 5;
            
            console.log("Beta Mode 2 parameters:", { alpha, beta });
            
            // Generate x values from 0 to 1 with fine resolution
            const numPoints = 1000;
            const xValues = [];
            for (let i = 0; i <= numPoints; i++) {
                xValues.push(i / numPoints);
            }
            
            // Calculate PDF values for the distribution
            const yValues = xValues.map(x => jStat.beta.pdf(x, alpha, beta));
            
            console.log("Generated PDF values, max:", Math.max(...yValues));
            
            // Calculate the 2.5% and 97.5% quantiles (95% confidence interval)
            const lowerQuantile = jStat.beta.inv(0.025, alpha, beta);
            const upperQuantile = jStat.beta.inv(0.975, alpha, beta);
            
            console.log("Confidence interval:", { lowerQuantile, upperQuantile });
            
            // Get the maximum y value for positioning vertical lines
            const maxY = Math.max(...yValues);
            
            // Create filled area under the curve for the confidence interval
            // Filter x and y values to only include the region between quantiles
            const ciXValues = [];
            const ciYValues = [];
            
            for (let i = 0; i < xValues.length; i++) {
                if (xValues[i] >= lowerQuantile && xValues[i] <= upperQuantile) {
                    ciXValues.push(xValues[i]);
                    ciYValues.push(yValues[i]);
                }
            }
            
            // Add the base line to close the fill area
            const fillX = [lowerQuantile, ...ciXValues, upperQuantile];
            const fillY = [0, ...ciYValues, 0];
            
            // Add the shaded confidence interval area
            traces.push({
                x: fillX,
                y: fillY,
                type: 'scatter',
                mode: 'none',
                fill: 'toself',
                fillcolor: 'rgba(0, 0, 255, 0.2)', // Same blue with transparency as the main curve
                line: { width: 0 },
                name: '95% CI Area',
                showlegend: false,
                hoverinfo: 'skip'
            });
            
            // Create trace for the distribution (on top of the shaded area)
            traces.push({
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines',
                name: `Beta(${alpha}, ${beta})`,
                line: {
                    color: 'rgb(0, 0, 255)',  // Blue
                    width: 2
                },
                hovertemplate: 'x: %{x:.3f}<br>PDF: %{y:.3f}<br>Beta(α=' + alpha + ', β=' + beta + ')<extra></extra>'
            });
            
            // Add vertical line for 2.5% quantile
            traces.push({
                x: [lowerQuantile, lowerQuantile],
                y: [0, maxY * 1.1],
                type: 'scatter',
                mode: 'lines',
                line: {
                    color: 'black',
                    dash: 'dot',
                    width: 2
                },
                name: '2.5%',
                showlegend: false,
                hovertemplate: '2.5% quantile: %{x:.3f}<extra></extra>'
            });
            
            // Add vertical line for 97.5% quantile
            traces.push({
                x: [upperQuantile, upperQuantile],
                y: [0, maxY * 1.1],
                type: 'scatter',
                mode: 'lines',
                line: {
                    color: 'black',
                    dash: 'dot',
                    width: 2
                },
                name: '97.5%',
                showlegend: false,
                hovertemplate: '97.5% quantile: %{x:.3f}<extra></extra>'
            });
            
            // Calculate the mode of the beta distribution
            let mode;
            if (alpha > 1 && beta > 1) {
                mode = (alpha - 1) / (alpha + beta - 2);
            } else if (alpha <= 1 && beta > 1) {
                mode = 0;
            } else if (alpha > 1 && beta <= 1) {
                mode = 1;
            } else {
                // Both alpha <= 1 and beta <= 1, mode is undefined or at endpoints
                mode = 0.5; // Use midpoint as fallback
            }
            
            // Calculate the PDF value at the mode
            const modeY = jStat.beta.pdf(mode, alpha, beta);
            
            console.log("Mode:", { mode, modeY });
            
            // Add vertical line at the mode
            traces.push({
                x: [mode, mode],
                y: [0, modeY],
                type: 'scatter',
                mode: 'lines',
                line: {
                    color: 'red',
                    width: 2
                },
                name: 'Mode',
                showlegend: false,
                hovertemplate: 'Mode: %{x:.3f}<extra></extra>'
            });
            
            // Add dot at the peak (top of the mode line)
            traces.push({
                x: [mode],
                y: [modeY],
                type: 'scatter',
                mode: 'markers',
                marker: {
                    color: 'red',
                    size: 8,
                    symbol: 'circle'
                },
                name: 'Peak',
                showlegend: false,
                hovertemplate: 'Peak: (%{x:.3f}, %{y:.3f})<extra></extra>'
            });
            
            // Add dot at the bottom (base of the mode line)
            traces.push({
                x: [mode],
                y: [0],
                type: 'scatter',
                mode: 'markers',
                marker: {
                    color: 'red',
                    size: 8,
                    symbol: 'circle'
                },
                name: 'Mode Base',
                showlegend: false,
                hovertemplate: 'Mode: %{x:.3f}<extra></extra>'
            });
            
            // Add annotation for the confidence interval (positioned higher)
            const midPoint = (lowerQuantile + upperQuantile) / 2;
            const annotationY = maxY * 1.2; // Positioned higher (was 0.8, now 0.9)
            
            // The annotation will be added in the layout, not here
            // Store the annotation data for later use
            traces.confidenceIntervalAnnotation = {
                x: midPoint,
                y: annotationY,
                text: '95% confidence interval',
                showarrow: false,
                font: {
                    size: 14,
                    color: 'black'
                },
                xanchor: 'center',
                yanchor: 'middle'
            };
            
            // Store the mode annotation data for later use (positioned within plot area)
            traces.modeAnnotation = {
                x: mode,
                y: modeY * 0.5, // Position at half the peak height within the plot
                text: `â = ${mode.toFixed(3)}`,
                showarrow: true,
                arrowhead: 2,
                arrowsize: 1,
                arrowwidth: 2,
                arrowcolor: 'red', // Red arrow
                ax: 28, // Arrow offset horizontally
                ay: -30, // Arrow offset vertically (points to peak)
                font: {
                    size: 14,
                    color: 'red' // Red text
                },
                xanchor: 'left',
                yanchor: 'middle'
            };
            
            console.log("Beta distribution 2 traces created:", traces.length);
        }
        
        function plotHistogramData(traces, selectedCategories) {
            console.log("plotHistogramData called with:", {
                selectedCategories,
                histogramData: JSON.stringify(histogramData).substring(0, 100) + "..."
            });
            
            // Get histogram parameters
            const binSize = parseInt(document.getElementById('histogramBinSize').value) || 400;
            const normalize = document.getElementById('histogramNormalize').checked;
            const overlay = document.getElementById('histogramOverlay').checked;
            const opacity = parseFloat(document.getElementById('histogramOpacity').value) || 0.7;
            
            console.log("Histogram parameters:", { binSize, normalize, overlay, opacity });
            
            // Get color stops based on current scheme
            const colorStops = getColorStops();

            // Function to interpolate between colors
            function interpolateColor(value) {
                // Find the color stops that bound our value
                for (let i = 0; i < colorStops.length - 1; i++) {
                    if (value >= colorStops[i].pos && value <= colorStops[i + 1].pos) {
                        const t = (value - colorStops[i].pos) / (colorStops[i + 1].pos - colorStops[i].pos);
                        const rgb = colorStops[i].color.map((start, j) => {
                            const end = colorStops[i + 1].color[j];
                            return Math.round(start + (end - start) * t);
                        });
                        return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                }
                return `rgb(${colorStops[colorStops.length - 1].color.join(',')})`;
            }
            
            // Find the overall range of data to create consistent bins
            let allValues = [];
            for (let category of selectedCategories) {
                if (histogramData[category] && Array.isArray(histogramData[category])) {
                    allValues = allValues.concat(histogramData[category]);
                }
            }
            
            if (allValues.length === 0) {
                console.log("No data to plot");
                return;
            }
            
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            console.log("Data range:", { minValue, maxValue, totalDataPoints: allValues.length });
            
            // Create bins starting from 0 with the specified bin size
            const numBins = Math.ceil(maxValue / binSize) + 1;
            const binEdges = [];
            for (let i = 0; i <= numBins; i++) {
                binEdges.push(i * binSize);
            }
            
            console.log("Bin configuration:", { numBins, binSize, binEdges: binEdges.slice(0, 5) + "..." });
            
            // Create histogram for each selected category
            let fillTraces = [];
            let outlineTraces = [];
            
            for (let i = 0; i < selectedCategories.length; i++) {
                const category = selectedCategories[i];
                
                if (!histogramData[category] || !Array.isArray(histogramData[category])) {
                    console.log(`Skipping category ${category}: invalid data`);
                    continue;
                }
                
                const values = histogramData[category];
                console.log(`Processing category ${category} with ${values.length} values`);
                
                // Normalize position for color interpolation
                const normalizedPos = selectedCategories.length === 1 ? 0.5 : 1 - (i / (selectedCategories.length - 1));
                const color = interpolateColor(normalizedPos);
                
                // Create filled histogram trace
                const fillTrace = {
                    x: values,
                    type: 'histogram',
                    name: category,
                    marker: {
                        color: color.replace('rgb', 'rgba').replace(')', `, ${opacity})`),
                        line: {
                            color: 'rgba(255,255,255,1.0)',
                            width: 1
                        }
                    },
                    xbins: {
                        start: 0,
                        end: binEdges[binEdges.length - 1],
                        size: binSize
                    },
                    histnorm: normalize ? 'probability density' : '',
                    hovertemplate: normalize ? 
                        'Response Length: %{x}<br>Density: %{y:.4f}<br>Category: ' + category + '<extra></extra>' :
                        'Response Length: %{x}<br>Count: %{y}<br>Category: ' + category + '<extra></extra>'
                };
                
                // Create outline-only trace
                const outlineTrace = {
                    x: values,
                    type: 'histogram',
                    name: category + ' (outline)',
                    showlegend: false,
                    marker: {
                        color: 'rgba(0,0,0,0)',  // Transparent fill
                        line: {
                            color: 'rgba(255,255,255,1.0)',
                            width: 1
                        }
                    },
                    xbins: {
                        start: 0,
                        end: binEdges[binEdges.length - 1],
                        size: binSize
                    },
                    histnorm: normalize ? 'probability density' : '',
                    hoverinfo: 'skip'  // Don't show hover for outline traces
                };
                
                fillTraces.push(fillTrace);
                outlineTraces.push(outlineTrace);
                console.log(`Added histogram traces for category ${category}`);
            }
            
            // Add fill traces in reverse order so blue (first category) overlays last
            for (let i = fillTraces.length - 1; i >= 0; i--) {
                traces.push(fillTraces[i]);
            }
            
            // Add all outline traces last so they appear on top
            for (let outlineTrace of outlineTraces.reverse()) {
                traces.push(outlineTrace);
            }
            
            console.log("Histogram traces created:", traces.length);
        }
        
        function selectAll(type) {
            const selector = type === 'questions' ? '#questionList' : '#probList';
            document.querySelectorAll(`${selector} input[type="checkbox"]`).forEach(cb => cb.checked = true);
            updatePlot();
        }
        
        function deselectAll(type) {
            const selector = type === 'questions' ? '#questionList' : '#probList';
            document.querySelectorAll(`${selector} input[type="checkbox"]`).forEach(cb => cb.checked = false);
            updatePlot();
        }
        
        // Function to load sample token data for testing
        function loadSampleTokenData() {
            console.log("Loading sample token data...");
            
            // Sample token data structure based on the actual data
            const sampleData = {
                "0.5": {
                    "0.6": [2624.11, 10000, 631],
                    "0.75": [2478.01, 10000, 542],
                    "0.9": [2553.97, 5626, 430],
                    "1.0": [2790.3, 5545, 572],
                    "1.1": [3202.57, 7398, 480],
                    "0.0": [3936.05, 10000, 778],
                    "0.25": [2994.65, 10000, 843],
                    "0.5": [2326.55, 10000, 466],
                    "1.25": [4494.6, 10000, 420],
                    "1.5": [9182.6, 10000, 306]
                },
                "0.0": {
                    "0.6": [2492.97, 10000, 435],
                    "0.75": [2244.27, 5619, 381],
                    "0.9": [2558.89, 5916, 440],
                    "1.0": [2375.8, 4716, 448],
                    "1.1": [3036.61, 6052, 427],
                    "0.0": [3304.7, 10000, 777],
                    "0.25": [2044.75, 10000, 444],
                    "0.5": [2817.05, 10000, 706],
                    "1.25": [6032.7, 10000, 2143],
                    "1.5": [8330.55, 10000, 524]
                }
            };
            
            // Set the token data
            tokenData = sampleData;
            accuracyData = null;
            
            // Update UI
            document.getElementById('dataStructureToggle').checked = true;
            document.getElementById('toggleLabel').textContent = "Token Count Data";
            document.getElementById('questionSection').style.display = 'none';
            
            // Create probability checkboxes
            const probList = document.getElementById('probList');
            probList.innerHTML = '';
            
            const uniqueProbs = Object.keys(tokenData).sort((a, b) => parseFloat(a) - parseFloat(b));
            console.log("Unique probabilities from sample token data:", uniqueProbs);
            
            for (let prob of uniqueProbs) {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label>
                        <input type="checkbox" value="${prob}" onclick="updatePlot()" checked>
                        <span>${parseFloat(prob).toFixed(2)}</span>
                    </label>
                `;
                probList.appendChild(div);
            }
            
            console.log("Sample token data loaded, updating plot...");
            updatePlot();
        }
        
        // Add a button to load sample data
        document.addEventListener('DOMContentLoaded', function() {
            const controlsDiv = document.querySelector('.controls');
            const loadSampleButton = document.createElement('button');
            loadSampleButton.textContent = "Load Sample Token Data";
            loadSampleButton.style.marginTop = "15px";
            loadSampleButton.style.width = "100%";
            loadSampleButton.style.padding = "8px";
            loadSampleButton.style.backgroundColor = "#4CAF50";
            loadSampleButton.style.color = "white";
            loadSampleButton.style.border = "none";
            loadSampleButton.style.borderRadius = "4px";
            loadSampleButton.style.cursor = "pointer";
            loadSampleButton.onclick = loadSampleTokenData;
            
            // Insert after file input
            const fileInput = document.querySelector('.file-input');
            fileInput.parentNode.insertBefore(loadSampleButton, fileInput.nextSibling);
            
            // Set default values for plot dimensions
            document.getElementById('plotWidth').value = Math.min(500, window.innerWidth - 250);
            document.getElementById('plotHeight').value = Math.min(450, window.innerHeight - 50);
            
            // Add reset dimensions button event listener
            document.getElementById('resetDimensions').addEventListener('click', function() {
                document.getElementById('plotWidth').value = Math.min(500, window.innerWidth - 250);
                document.getElementById('plotHeight').value = Math.min(450, window.innerHeight - 50);
                updatePlot();
            });
        });
        
        // Add window resize handler
        window.addEventListener('resize', function() {
            // Only update if the plot is already displayed
            if (document.getElementById('plot').innerHTML !== '') {
                updatePlot();
            }
        });
        
        // Add bar chart toggle to the controls
        document.addEventListener('DOMContentLoaded', function() {
            // Add bar chart toggle
            const toggleContainer = document.createElement('div');
            toggleContainer.className = 'toggle-container';
            toggleContainer.innerHTML = `
                <div style="margin-bottom: 8px; font-weight: 600;">Chart Type:</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="barChartToggle" onclick="toggleBarChartMode()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="barChartToggleLabel">Line Chart</span>
            `;
            
            // Insert after data structure toggle
            const dataStructureToggle = document.querySelector('.toggle-container');
            dataStructureToggle.parentNode.insertBefore(toggleContainer, dataStructureToggle.nextSibling);
            
            // Add event listener for bar chart toggle
            document.getElementById('barChartToggle').addEventListener('change', function() {
                toggleBarChartMode();
            });
            
            // Function to update bar width value display
            window.updateBarWidthValue = function(val) {
                document.getElementById('barWidthValue').textContent = val;
            };
            
            // Function to update histogram opacity value display
            window.updateHistogramOpacityValue = function(val) {
                document.getElementById('histogramOpacityValue').textContent = val;
            };
            
            // Function to update text line length value display
            window.updateTextLineLengthValue = function(val) {
                document.getElementById('textLineLengthValue').textContent = val;
            };
            
            // Function to toggle bar chart mode
            window.toggleBarChartMode = function() {
                const toggleLabel = document.getElementById('barChartToggleLabel');
                const barChartOptions = document.getElementById('barChartOptions');
                
                if (document.getElementById('barChartToggle').checked) {
                    toggleLabel.textContent = "Bar Chart";
                    barChartOptions.style.display = 'block';
                } else {
                    toggleLabel.textContent = "Line Chart";
                    barChartOptions.style.display = 'none';
                }
                updatePlot();
            };
            
            // Load sample injection data function
            window.loadSampleInjectionData = function() {
                console.log("Loading sample injection data...");
                
                // Sample injection data structure
                const sampleData = {
                    "1": {
                        "I'm confused.": [14, 50],
                        "I'm not sure.": [12, 50],
                        "I don't know.": [10, 50],
                        "Let me think...": [18, 50]
                    },
                    "2": {
                        "I'm confused.": [20, 50],
                        "I'm not sure.": [18, 50],
                        "I don't know.": [15, 50],
                        "Let me think...": [22, 50]
                    },
                    "3": {
                        "I'm confused.": [25, 50],
                        "I'm not sure.": [23, 50],
                        "I don't know.": [20, 50],
                        "Let me think...": [28, 50]
                    }
                };
                
                // Set the injection data
                injectionData = sampleData;
                accuracyData = null;
                tokenData = null;
                
                // Update UI
                document.getElementById('dataStructureToggle').checked = false;
                document.getElementById('toggleLabel').textContent = "Accuracy Data";
                document.getElementById('questionSection').style.display = 'block';
                document.getElementById('barChartToggle').checked = true;
                document.getElementById('barChartToggleLabel').textContent = "Bar Chart";
                document.getElementById('barChartToggle').parentElement.style.display = 'block';
                document.getElementById('barChartOptions').style.display = 'block';
                
                // Create question checkboxes
                const questionList = document.getElementById('questionList');
                questionList.innerHTML = '';
                
                for (let question in injectionData) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label>
                            <input type="checkbox" value="${question}" onclick="updatePlot()" checked>
                            <span>${question}</span>
                        </label>
                    `;
                    questionList.appendChild(div);
                }
                
                // Create injection string checkboxes
                const probList = document.getElementById('probList');
                probList.innerHTML = '';
                
                const uniqueInjections = [...new Set(
                    Object.values(injectionData).flatMap(q => Object.keys(q))
                )];
                
                for (let injection of uniqueInjections) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label>
                            <input type="checkbox" value="${injection}" onclick="updatePlot()" checked>
                            <span>${injection}</span>
                        </label>
                    `;
                    probList.appendChild(div);
                }
                
                console.log("Sample injection data loaded, updating plot...");
                updatePlot();
            };
            
            // Load sample histogram data function
            window.loadSampleHistogramData = function() {
                console.log("Loading sample histogram data...");
                
                // Sample histogram data structure - response lengths for different categories
                const sampleData = {
                    "Low Temperature": [
                        450, 523, 678, 892, 765, 543, 432, 567, 689, 745,
                        834, 912, 656, 478, 589, 723, 845, 567, 623, 789,
                        432, 654, 876, 543, 678, 789, 456, 567, 823, 945,
                        678, 543, 789, 612, 734, 856, 567, 689, 745, 823,
                        456, 678, 789, 612, 745, 867, 589, 723, 845, 967
                    ],
                    "Medium Temperature": [
                        1200, 1456, 1789, 2134, 1567, 1823, 1345, 1678, 1912, 2245,
                        1456, 1789, 2023, 1567, 1834, 2156, 1789, 2012, 1645, 1923,
                        1567, 1834, 2156, 1789, 2012, 1645, 1923, 2267, 1834, 2156,
                        1456, 1789, 2023, 1567, 1834, 2156, 1789, 2012, 1645, 1923,
                        1234, 1567, 1890, 2123, 1456, 1789, 2012, 1645, 1923, 2267
                    ],
                    "High Temperature": [
                        2400, 2789, 3156, 3523, 3890, 4257, 3624, 3991, 4358, 4725,
                        2834, 3201, 3568, 3935, 4302, 3669, 4036, 4403, 4770, 5137,
                        3267, 3634, 4001, 4368, 4735, 4102, 4469, 4836, 5203, 5570,
                        3700, 4067, 4434, 4801, 5168, 4535, 4902, 5269, 5636, 6003,
                        4133, 4500, 4867, 5234, 5601, 4968, 5335, 5702, 6069, 6436
                    ]
                };
                
                // Set the histogram data
                histogramData = sampleData;
                accuracyData = null;
                tokenData = null;
                injectionData = null;
                
                // Update UI
                document.getElementById('dataStructureToggle').checked = false;
                document.getElementById('toggleLabel').textContent = "Histogram Data";
                document.getElementById('questionSection').style.display = 'block';
                if (document.getElementById('barChartToggle')) {
                    document.getElementById('barChartToggle').checked = false;
                    document.getElementById('barChartToggle').parentElement.style.display = 'block';
                }
                
                // Show histogram controls
                document.getElementById('histogramControls').style.display = 'block';
                
                // Create category checkboxes (treated as questions)
                const questionList = document.getElementById('questionList');
                questionList.innerHTML = '';
                
                for (let category in histogramData) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label>
                            <input type="checkbox" value="${category}" onclick="updatePlot()" checked>
                            <span>${category}</span>
                        </label>
                    `;
                    questionList.appendChild(div);
                }
                
                // Clear probability list for histogram data
                const probList = document.getElementById('probList');
                probList.innerHTML = '';
                
                console.log("Sample histogram data loaded, updating plot...");
                updatePlot();
            };
            
            // Add sample injection data button
            const loadSampleInjectionButton = document.createElement('button');
            loadSampleInjectionButton.textContent = "Load Sample Injection Data";
            loadSampleInjectionButton.style.marginTop = "10px";
            loadSampleInjectionButton.style.width = "100%";
            loadSampleInjectionButton.style.padding = "8px";
            loadSampleInjectionButton.style.backgroundColor = "#9C27B0";
            loadSampleInjectionButton.style.color = "white";
            loadSampleInjectionButton.style.border = "none";
            loadSampleInjectionButton.style.borderRadius = "4px";
            loadSampleInjectionButton.style.cursor = "pointer";
            loadSampleInjectionButton.onclick = window.loadSampleInjectionData;
            
            // Insert after sample token data button
            const loadSampleButton = document.querySelector('.controls button');
            loadSampleButton.parentNode.insertBefore(loadSampleInjectionButton, loadSampleButton.nextSibling);
            
            // Add sample histogram data button
            const loadSampleHistogramButton = document.createElement('button');
            loadSampleHistogramButton.textContent = "Load Sample Histogram Data";
            loadSampleHistogramButton.style.marginTop = "10px";
            loadSampleHistogramButton.style.width = "100%";
            loadSampleHistogramButton.style.padding = "8px";
            loadSampleHistogramButton.style.backgroundColor = "#FF5722";
            loadSampleHistogramButton.style.color = "white";
            loadSampleHistogramButton.style.border = "none";
            loadSampleHistogramButton.style.borderRadius = "4px";
            loadSampleHistogramButton.style.cursor = "pointer";
            loadSampleHistogramButton.onclick = window.loadSampleHistogramData;
            
            // Insert after sample injection data button
            loadSampleButton.parentNode.insertBefore(loadSampleHistogramButton, loadSampleInjectionButton.nextSibling);
        });
    </script>
</body>
</html> 